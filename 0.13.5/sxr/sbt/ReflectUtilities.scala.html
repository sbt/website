<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/ReflectUtilities.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2008 David MacIver, Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> scala.collection._

<span class="keyword">object</span> <a title="sbt.ReflectUtilities.type" id="sbt.ReflectUtilities">ReflectUtilities</a>
<a href="#sbt.ReflectUtilities" title="sbt.ReflectUtilities.type" class="delimiter">{</a>
	<span class="comment">/** Converts the camelCase String `name` to lowercase separated by `separator`. */</span>
	<span class="keyword">def</span> <a title="(name: String, separator: Char)String" id="sbt.ReflectUtilities.transformCamelCase">transformCamelCase</a><span class="delimiter">(</span><a title="String" id="sbt.ReflectUtilities.transformCamelCase.name">name</a>: <span title="String">String</span>, <a title="Char" id="sbt.ReflectUtilities.transformCamelCase.separator">separator</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <span title="String">String</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="StringBuilder" id="sbt.ReflectUtilities.transformCamelCase.buffer">buffer</a> = <span title="()StringBuilder" class="keyword">new</span> <span title="StringBuilder">StringBuilder</span>
		<span class="keyword">for</span><span class="delimiter">(</span><a title="Char" id="sbt.ReflectUtilities.transformCamelCase.$anonfun.char">char</a> &lt;- <a href="#sbt.ReflectUtilities.transformCamelCase.name" title="(f: Char =&gt; StringBuilder)Unit">name</a><span class="delimiter">)</span>
		<span class="delimiter">{</span>
			<span class="keyword">import</span> java.lang.<span title="Character.type">Character</span>._
			<span title="buffer.type" class="keyword">if</span><span class="delimiter">(</span><span title="(x$1: Char)Boolean">isUpperCase</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.transformCamelCase.$anonfun.char" title="Char">char</a><span class="delimiter">)</span><span class="delimiter">)</span>
			<span class="delimiter">{</span>
				<a href="#sbt.ReflectUtilities.transformCamelCase.buffer" title="StringBuilder">buffer</a> <span title="(x: Char)buffer.type">+=</span> <a href="#sbt.ReflectUtilities.transformCamelCase.separator" title="Char">separator</a>
				<a href="#sbt.ReflectUtilities.transformCamelCase.buffer" title="StringBuilder">buffer</a> <span title="(x: Char)buffer.type">+=</span> <span title="(x$1: Char)Char">toLowerCase</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.transformCamelCase.$anonfun.char" title="Char">char</a><span class="delimiter">)</span>
			<span class="delimiter">}</span>
			<span class="keyword">else</span>
				<a href="#sbt.ReflectUtilities.transformCamelCase.buffer" title="StringBuilder">buffer</a> <span title="(x: Char)buffer.type">+=</span> <a href="#sbt.ReflectUtilities.transformCamelCase.$anonfun.char" title="Char">char</a>
		<span class="delimiter">}</span>
		<a href="#sbt.ReflectUtilities.transformCamelCase.buffer" title="StringBuilder">buffer</a>.<span title="()String">toString</span>
	<span class="delimiter">}</span>

	<span class="keyword">def</span> <a title="(clazz: Class[_])List[Class[_]]" id="sbt.ReflectUtilities.ancestry">ancestry</a><span class="delimiter">(</span><a title="Class[_]" id="sbt.ReflectUtilities.ancestry.clazz">clazz</a> : <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> : <span title="List[Class[_]]">List</span><span class="delimiter">[</span>Class<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = 
		<span title="List[Class[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.ReflectUtilities.ancestry.clazz" title="Class[_]">clazz</a> <span title="(x$1: AnyRef)Boolean">==</span> classOf<span title="Class[AnyRef](classOf[java.lang.Object])" class="delimiter">[</span>AnyRef<span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span>classOf<span title="Class[AnyRef](classOf[java.lang.Object])" class="delimiter">[</span>AnyRef<span class="delimiter">]</span>.<span title="(x$1: Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.ancestry.clazz" title="Class[_]">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(xs: Class[_$1]*)List[Class[_$1]]">List</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.ancestry.clazz" title="Class[_]">clazz</a><span class="delimiter">)</span>
		<span class="keyword">else</span> <a href="#sbt.ReflectUtilities.ancestry.clazz" title="Class[_]">clazz</a> <a href="#sbt.ReflectUtilities.ancestry.x$1" title="(x: Class[_])List[Class[_]]">::</a> <a href="#sbt.ReflectUtilities.ancestry" title="(clazz: Class[_])List[Class[_]]">ancestry</a><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.ancestry.clazz" title="Class[_]">clazz</a>.<span title="()Class[_ &gt;: _$1]">getSuperclass</span><span class="delimiter">)</span>;

	<span class="keyword">def</span> <a title="(clazz: Class[_])scala.collection.mutable.OpenHashMap[String,java.lang.reflect.Field]" id="sbt.ReflectUtilities.fields">fields</a><span class="delimiter">(</span><a title="Class[_]" id="sbt.ReflectUtilities.fields.clazz">clazz</a> : <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = 
		mutable.<span title="(elems: (String, java.lang.reflect.Field)*)scala.collection.mutable.OpenHashMap[String,java.lang.reflect.Field]">OpenHashMap</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.ancestry" title="(clazz: Class[_])List[Class[_]]">ancestry</a><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.fields.clazz" title="Class[_]">clazz</a><span class="delimiter">)</span>.
			<span title="(f: Class[_] =&gt; scala.collection.GenTraversableOnce[java.lang.reflect.Field])(implicit bf: scala.collection.generic.CanBuildFrom[List[Class[_]],java.lang.reflect.Field,List[java.lang.reflect.Field]])List[java.lang.reflect.Field]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,java.lang.reflect.Field,List[java.lang.reflect.Field]]" class="delimiter">(</span><a href="#sbt.ReflectUtilities.fields.$anonfun.x$2" title="Class[_]">_</a>.<span title="(xs: Array[java.lang.reflect.Field])scala.collection.mutable.ArrayOps[java.lang.reflect.Field]">getDeclaredFields</span><span class="delimiter">)</span>.
			<span title="(f: java.lang.reflect.Field =&gt; (String, java.lang.reflect.Field))(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.reflect.Field],(String, java.lang.reflect.Field),List[(String, java.lang.reflect.Field)]])List[(String, java.lang.reflect.Field)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(String, java.lang.reflect.Field),List[(String, java.lang.reflect.Field)]]" class="delimiter">(</span><a title="java.lang.reflect.Field" id="sbt.ReflectUtilities.fields.$anonfun.f">f</a> =&gt; <span title="(_1: String, _2: java.lang.reflect.Field)(String, java.lang.reflect.Field)" class="delimiter">(</span><a href="#sbt.ReflectUtilities.fields.$anonfun.f" title="java.lang.reflect.Field">f</a>.<span title="()String">getName</span>, <a href="#sbt.ReflectUtilities.fields.$anonfun.f" title="java.lang.reflect.Field">f</a><span class="delimiter">)</span><span class="delimiter">)</span>:_*<span class="delimiter">)</span>
	
	<span class="comment">/** Collects all `val`s of type `T` defined on value `self`.
	* The returned Map maps the name of each `val` to its value.
	* This depends on scalac implementation details to determine what is a `val` using only Java reflection. */</span>
	<span class="keyword">def</span> <a title="[T](self: AnyRef, clazz: Class[T])scala.collection.immutable.SortedMap[String,T]" id="sbt.ReflectUtilities.allValsC">allValsC</a><span class="delimiter">[</span><a title="" id="sbt.ReflectUtilities.allValsC;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="AnyRef" id="sbt.ReflectUtilities.allValsC.self">self</a>: <span title="AnyRef">AnyRef</span>, <a title="Class[T]" id="sbt.ReflectUtilities.allValsC.clazz">clazz</a>: <span title="Class[T]">Class</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: immutable.<span title="scala.collection.immutable.SortedMap[String,T]">SortedMap</span><span class="delimiter">[</span>String, T<span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">var</span> <a title="scala.collection.immutable.TreeMap[String,T]" id="sbt.ReflectUtilities.allValsC.mappings">mappings</a> = <span title="()(implicit ordering: Ordering[String])scala.collection.immutable.TreeMap[String,T]" class="keyword">new</span> immutable.<span title="scala.collection.immutable.TreeMap[String,T]">TreeMap</span><span class="delimiter">[</span>String, T<span class="delimiter">]</span>
		<span class="keyword">val</span> <a title="scala.collection.mutable.OpenHashMap[String,java.lang.reflect.Field]" id="sbt.ReflectUtilities.allValsC.correspondingFields">correspondingFields</a> = <a href="#sbt.ReflectUtilities.fields" title="(clazz: Class[_])scala.collection.mutable.OpenHashMap[String,java.lang.reflect.Field]">fields</a><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.self" title="AnyRef">self</a>.<span title="()Class[_]">getClass</span><span class="delimiter">)</span>
		<span class="keyword">for</span><span class="delimiter">(</span><a title="java.lang.reflect.Method" id="sbt.ReflectUtilities.allValsC.$anonfun.method">method</a> &lt;- <a href="#sbt.ReflectUtilities.allValsC.self" title="AnyRef">self</a>.<span title="()Class[_]">getClass</span>.<span title="(f: java.lang.reflect.Method =&gt; Unit)Unit">getMethods</span><span class="delimiter">)</span>
		<span class="delimiter">{</span>
			<span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="()Array[Class[_]]">getParameterTypes</span>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.ReflectUtilities.allValsC.clazz" title="Class[T]">clazz</a>.<span title="(x$1: Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="()Class[_]">getReturnType</span><span class="delimiter">)</span><span class="delimiter">)</span>
			<span class="delimiter">{</span>
				<span class="keyword">for</span><span class="delimiter">(</span><a title="java.lang.reflect.Field" id="sbt.ReflectUtilities.allValsC.$anonfun.$anonfun.field">field</a> &lt;- <a href="#sbt.ReflectUtilities.allValsC.correspondingFields" title="scala.collection.mutable.OpenHashMap[String,java.lang.reflect.Field]">correspondingFields</a>.<span title="(key: String)Option[java.lang.reflect.Field]">get</span><span title="(f: java.lang.reflect.Field =&gt; Unit)Unit" class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="()String">getName</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.ReflectUtilities.allValsC.$anonfun.$anonfun.field" title="java.lang.reflect.Field">field</a>.<span title="()Class[_]">getType</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="()Class[_]">getReturnType</span><span class="delimiter">)</span>
				<span class="delimiter">{</span>
					<span class="keyword">val</span> <a title="T" id="sbt.ReflectUtilities.allValsC.$anonfun.$anonfun.value">value</a> = <a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="(x$1: Any, x$2: &lt;repeated...&gt;[Object])Object">invoke</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.self" title="AnyRef">self</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#sbt.ReflectUtilities.allValsC;T" title="T">T</a><span class="delimiter">]</span>
					<span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.$anonfun.$anonfun.value" title="T">value</a> <span title="(x$1: Any)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="sbt.UninitializedVal" class="keyword">new</span> <a href="#sbt;UninitializedVal" title="sbt.UninitializedVal">UninitializedVal</a><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="()String">getName</span>, <a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="()Class[_]">getDeclaringClass</span>.<span title="()String">getName</span><span class="delimiter">)</span>
					<a href="#sbt.ReflectUtilities.allValsC.mappings" title="scala.collection.immutable.TreeMap[String,T]">mappings</a> <span title="(kv: (String, T))scala.collection.immutable.TreeMap[String,T]">+=</span> <span class="delimiter">(</span><span title="(_1: String, _2: T)(String, T)" class="delimiter">(</span><a href="#sbt.ReflectUtilities.allValsC.$anonfun.method" title="java.lang.reflect.Method">method</a>.<span title="()String">getName</span>, <a href="#sbt.ReflectUtilities.allValsC.$anonfun.$anonfun.value" title="T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
				<span class="delimiter">}</span>
			<span class="delimiter">}</span>
		<span class="delimiter">}</span>
		<a href="#sbt.ReflectUtilities.allValsC.mappings" title="scala.collection.immutable.TreeMap[String,T]">mappings</a>
	<span class="delimiter">}</span>

	<span class="comment">/** Collects all `val`s of type `T` defined on value `self`.
	* The returned Map maps the name of each `val` to its value.
	* This requires an available `Manifest` for `T` and depends on scalac implementation details to determine
	* what is a `val` using only Java reflection. */</span>
	<span class="keyword">def</span> <a title="[T](self: AnyRef)(implicit mt: scala.reflect.Manifest[T])scala.collection.immutable.SortedMap[String,T]" id="sbt.ReflectUtilities.allVals">allVals</a><span class="delimiter">[</span><a title="" id="sbt.ReflectUtilities.allVals;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="AnyRef" id="sbt.ReflectUtilities.allVals.self">self</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.reflect.Manifest[T]" id="sbt.ReflectUtilities.allVals.mt">mt</a>: scala.reflect.<span title="scala.reflect.Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: immutable.<span title="scala.collection.immutable.SortedMap[String,T]">SortedMap</span><span class="delimiter">[</span>String, T<span class="delimiter">]</span> =
		<a href="#sbt.ReflectUtilities.allValsC" title="(self: AnyRef, clazz: Class[_$1])scala.collection.immutable.SortedMap[String,_$1]">allValsC</a><span class="delimiter">(</span><a href="#sbt.ReflectUtilities.allVals.self" title="AnyRef">self</a>, <a href="#sbt.ReflectUtilities.allVals.mt" title="scala.reflect.Manifest[T]">mt</a>.<span title="=&gt; Class[_]">runtimeClass</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.collection.immutable.SortedMap[String,T]" class="delimiter">[</span>immutable.<span title="scala.collection.immutable.SortedMap[String,T]">SortedMap</span><span class="delimiter">[</span>String,T<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="comment">/** An exception to indicate that while traversing the `val`s for an instance of `className`, the `val` named `valName` was `null`. */</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a title="class UninitializedVal extends RuntimeException" id="sbt;UninitializedVal">UninitializedVal</a><a href="#sbt;UninitializedVal" title="sbt.UninitializedVal" class="delimiter">(</a><span class="keyword">val</span> <a title="String" id="sbt;UninitializedVal.valName">valName</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="String" id="sbt;UninitializedVal.className">className</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="String(&quot;val &quot;)" class="string">&quot;val &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;UninitializedVal.valName" title="String">valName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; in class &quot;)" class="string">&quot; in class &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;UninitializedVal.className" title="String">className</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; was null.\nThis is probably an initialization problem and a \'lazy val\' should be used.&quot;)" class="string">&quot; was null.\nThis is probably an initialization problem and a 'lazy val' should be used.&quot;</span><span class="delimiter">)</span>
        </pre>
    </body>
</html>
