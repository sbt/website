<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/KList.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt

	<span class="keyword">import</span> <a href="Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>._
	<span class="keyword">import</span> <a href="Classes.scala.html#sbt.Classes" title="sbt.Classes.type">Classes</a>.Applicative

<span class="comment">/** Heterogeneous list with each element having type M[T] for some type T.*/</span>
<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait KList[+M[_]] extends AnyRef" id="sbt;KList">KList</a><span class="delimiter">[</span>+<a title="[_]" id="sbt;KList;M">M</a><span class="delimiter">[</span><a title="" id="sbt;KList;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span>
<span title="Unit" class="delimiter">{</span>
	<span class="keyword">type</span> <a title="[N[_]] &lt;: sbt.KList[N]" id="sbt;KList;Transform">Transform</a><span class="delimiter">[</span><a title="[_]" id="sbt;KList;Transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KList;Transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> &lt;: KList<span class="delimiter">[</span>N<span class="delimiter">]</span>

	<span class="comment">/** Apply the natural transformation `f` to each element. */</span>
	<span class="keyword">def</span> <a title="[N[_]](f: sbt.~&gt;[M,N])KList.this.Transform[N]" id="sbt;KList.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt;KList.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KList.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[M,N]" id="sbt;KList.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span>: <a href="#sbt;KList;Transform" title="KList.this.Transform[N]">Transform</a><span class="delimiter">[</span>N<span class="delimiter">]</span>

	<span class="comment">/** Folds this list using a function that operates on the homogeneous type of the elements of this list. */</span>
	<span class="keyword">def</span> <a title="[T](f: (M[_], T) =&gt; T, init: T)T" id="sbt;KList.foldr">foldr</a><span class="delimiter">[</span><a title="" id="sbt;KList.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[_], T) =&gt; T" id="sbt;KList.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt;KList.foldr.init">init</a>: <a href="#sbt;KList.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt;KList.foldr;T" title="T">T</a> = <a href="#sbt;KList.foldr.init" title="T">init</a> <span class="comment">// had trouble defining it in KNil</span>

	<span class="comment">/** Applies `f` to the elements of this list in the applicative functor defined by `ap`. */</span>
	<span class="keyword">def</span> <a title="[N[x] &gt;: M[x], Z](f: KList.this.Transform[sbt.Types.Id] =&gt; Z)(implicit ap: sbt.Classes.Applicative[N])N[Z]" id="sbt;KList.apply">apply</a><span class="delimiter">[</span><a title="[x] &gt;: M[x]" id="sbt;KList.apply;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KList.apply;N;x">x</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="sbt;KList.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="KList.this.Transform[sbt.Types.Id] =&gt; Z" id="sbt;KList.apply.f">f</a>: Transform<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt;KList.apply.ap">ap</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;KList.apply;N" title="N[Z]">N</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>

	<span class="comment">/** Equivalent to `transform(f) . apply(x =&gt; x)`, this is the essence of the iterator at the level of natural transformations.*/</span>
	<span class="keyword">def</span> <a title="[N[_], P[_]](f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[KList.this.Transform[P]]" id="sbt;KList.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt;KList.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KList.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;KList.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt;KList.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt;KList.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N ∙ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt;KList.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;KList.traverse;N" title="N[KList.this.Transform[P]]">N</a><span class="delimiter">[</span>Transform<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span>

	<span class="comment">/** Discards the heterogeneous type information and constructs a plain List from this KList's elements. */</span>
	<span class="keyword">def</span> <a title="=&gt; List[M[_]]" id="sbt;KList.toList">toList</a>: <span title="List[M[_]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">case class</span> <a href="#sbt;KCons.productElement.x$1" title="class KCons[H, +T &lt;: sbt.KList[M], +M[_]] extends AnyRef with sbt.KList[M] with Product with Serializable" id="sbt.KCons.readResolve">KCons</a><span class="delimiter">[</span><a title="" id="sbt;KCons;H">H</a>, +<a title=" &lt;: sbt.KList[M]" id="sbt;KCons;T">T</a> &lt;: KList<span class="delimiter">[</span>M<span class="delimiter">]</span>, +<a title="[_]" id="sbt;KCons;M">M</a><span class="delimiter">[</span><a title="" id="sbt;KCons;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.KCons.readResolve" title="Product" class="delimiter">(</a><a title="M[H]" id="sbt;KCons.head">head</a>: <a href="#sbt;KCons;M" title="M[H]">M</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a title="T" id="sbt;KCons.tail">tail</a>: <a href="#sbt;KCons;T" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;KList" title="sbt.KList[M]">KList</a><span class="delimiter">[</span>M<span class="delimiter">]</span>
<span class="delimiter">{</span>
	<span class="keyword">final</span> <span class="keyword">type</span> <a title="[N[_]]sbt.KCons[H,KCons.this.tail.Transform[N],N]" id="sbt;KCons;Transform">Transform</a><span class="delimiter">[</span><a title="[_]" id="sbt;KCons;Transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KCons;Transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.KCons.readResolve" title="sbt.KCons[H,KCons.this.tail.Transform[N],N]">KCons</a><span class="delimiter">[</span>H, tail.Transform<span class="delimiter">[</span>N<span class="delimiter">]</span>, N<span class="delimiter">]</span>

	<span class="keyword">def</span> <a title="[N[_]](f: sbt.~&gt;[M,N])sbt.KCons[H,KCons.this.tail.Transform[N],N]" id="sbt;KCons.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt;KCons.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KCons.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[M,N]" id="sbt;KCons.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <a href="#sbt.KCons.readResolve" title="(head: N[H], tail: KCons.this.tail.Transform[N])sbt.KCons[H,KCons.this.tail.Transform[N],N]">KCons</a><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[H]">f</a><span class="delimiter">(</span><a href="#sbt;KCons.head" title="=&gt; M[H]">head</a><span class="delimiter">)</span>, <a href="#sbt;KCons.tail" title="=&gt; T">tail</a>.<a href="#sbt;KList.transform" title="(f: sbt.~&gt;[M,N])KCons.this.tail.Transform[N]">transform</a><span class="delimiter">(</span><a href="#sbt;KCons.transform.f" title="sbt.~&gt;[M,N]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="=&gt; List[M[_]]" id="sbt;KCons.toList">toList</a>: <span title="List[M[_]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;KCons.head" title="=&gt; M[H]">head</a> <a href="#sbt;KCons.toList.x$1" title="(x: M[_])List[M[_]]">::</a> <a href="#sbt;KCons.tail" title="=&gt; T">tail</a>.<a href="#sbt;KList.toList" title="=&gt; List[M[_]]">toList</a>
	<span class="keyword">def</span> <a title="[N[x] &gt;: M[x], Z](f: KCons.this.Transform[sbt.Types.Id] =&gt; Z)(implicit ap: sbt.Classes.Applicative[N])N[Z]" id="sbt;KCons.apply">apply</a><span class="delimiter">[</span><a title="[x] &gt;: M[x]" id="sbt;KCons.apply;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KCons.apply;N;x">x</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>x<span class="delimiter">]</span>, <a title="" id="sbt;KCons.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="KCons.this.Transform[sbt.Types.Id] =&gt; Z" id="sbt;KCons.apply.f">f</a>: Transform<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt;KCons.apply.ap">ap</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;KCons.apply;N" title="N[Z]">N</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="KCons.this.tail.Transform[sbt.Types.Id] =&gt; (H =&gt; Z)" id="sbt;KCons.apply.g">g</a> = <span class="delimiter">(</span>t: tail.<a href="#sbt;KList;Transform" title="KCons.this.tail.Transform[sbt.Types.Id]">Transform</a><span class="delimiter">[</span>Id<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>h: <a href="#sbt;KCons;H" title="H">H</a><span class="delimiter">)</span> =&gt;<a href="#sbt;KCons.apply.f" title="(v1: KCons.this.Transform[sbt.Types.Id])Z">f</a><span class="delimiter">(</span> <a href="#sbt.KCons.readResolve" title="[H, T &lt;: sbt.KList[M], M[_]](head: M[H], tail: T)sbt.KCons[H,T,M]">KCons</a><span title="(head: sbt.Types.Id[H], tail: KCons.this.tail.Transform[sbt.Types.Id])sbt.KCons[H,KCons.this.tail.Transform[sbt.Types.Id],sbt.Types.Id]" class="delimiter">[</span><a href="#sbt;KCons;H" title="H">H</a>, tail.<a href="#sbt;KList;Transform" title="KCons.this.tail.Transform[sbt.Types.Id]">Transform</a><span class="delimiter">[</span>Id<span class="delimiter">]</span>, <a href="TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;KCons.apply.g.$anonfun.$anonfun.h" title="H">h</a>, <a href="#sbt;KCons.apply.g.$anonfun.t" title="KCons.this.tail.Transform[sbt.Types.Id]">t</a><span class="delimiter">)</span> <span class="delimiter">)</span>
		<a href="#sbt;KCons.apply.ap" title="sbt.Classes.Applicative[N]">ap</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[H =&gt; Z], v: N[H])N[Z]">apply</a><span class="delimiter">(</span> <a href="#sbt;KCons.tail" title="=&gt; T">tail</a>.<a href="#sbt;KList.apply" title="[N[x] &gt;: M[x], Z](f: KCons.this.tail.Transform[sbt.Types.Id] =&gt; Z)(implicit ap: sbt.Classes.Applicative[N])N[Z]">apply</a><span title="(f: KCons.this.tail.Transform[sbt.Types.Id] =&gt; (H =&gt; Z))(implicit ap: sbt.Classes.Applicative[N])N[H =&gt; Z]" class="delimiter">[</span><a href="#sbt;KCons.apply;N" title="N">N</a>, H =&gt; Z<span class="delimiter">]</span><a href="#sbt;KCons.apply.ap" title="sbt.Classes.Applicative[N]" class="delimiter">(</a><a href="#sbt;KCons.apply.g" title="KCons.this.tail.Transform[sbt.Types.Id] =&gt; (H =&gt; Z)">g</a><span class="delimiter">)</span>, <a href="#sbt;KCons.head" title="=&gt; M[H]">head</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="keyword">def</span> <a title="[N[_], P[_]](f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[KCons.this.Transform[P]]" id="sbt;KCons.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt;KCons.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KCons.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;KCons.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt;KCons.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt;KCons.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N ∙ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt;KCons.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;KCons.traverse;N" title="N[KCons.this.Transform[P]]">N</a><span class="delimiter">[</span>Transform<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="N[KCons.this.tail.Transform[P]]" id="sbt;KCons.traverse.tt">tt</a>: <a href="#sbt;KCons.traverse;N" title="N[KCons.this.tail.Transform[P]]">N</a><span class="delimiter">[</span>tail.Transform<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;KCons.tail" title="=&gt; T">tail</a>.<a href="#sbt;KList.traverse" title="[N[_], P[_]](f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[KCons.this.tail.Transform[P]]">traverse</a><span title="(f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[KCons.this.tail.Transform[P]]" class="delimiter">[</span><a href="#sbt;KCons.traverse;N" title="N">N</a>,<a href="#sbt;KCons.traverse;P" title="P">P</a><span class="delimiter">]</span><a href="#sbt;KCons.traverse.np" title="sbt.Classes.Applicative[N]" class="delimiter">(</a><a href="#sbt;KCons.traverse.f" title="sbt.~&gt;[M,[T]N[P[T]]]">f</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="KCons.this.tail.Transform[P] =&gt; (P[H] =&gt; sbt.KCons[H,KCons.this.tail.Transform[P],P])" id="sbt;KCons.traverse.g">g</a> = <span class="delimiter">(</span>t: tail.<a href="#sbt;KList;Transform" title="KCons.this.tail.Transform[P]">Transform</a><span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>h: <a href="#sbt;KCons.traverse;P" title="P[H]">P</a><span class="delimiter">[</span>H<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#sbt.KCons.readResolve" title="(head: P[H], tail: KCons.this.tail.Transform[P])sbt.KCons[H,KCons.this.tail.Transform[P],P]">KCons</a><span class="delimiter">(</span><a href="#sbt;KCons.traverse.g.$anonfun.$anonfun.h" title="P[H]">h</a>, <a href="#sbt;KCons.traverse.g.$anonfun.t" title="KCons.this.tail.Transform[P]">t</a><span class="delimiter">)</span>
		<a href="#sbt;KCons.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[H] =&gt; sbt.KCons[H,KCons.this.tail.Transform[P],P]], v: N[P[H]])N[sbt.KCons[H,KCons.this.tail.Transform[P],P]]">apply</a><span class="delimiter">(</span><a href="#sbt;KCons.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: KCons.this.tail.Transform[P] =&gt; (P[H] =&gt; sbt.KCons[H,KCons.this.tail.Transform[P],P]), v: N[KCons.this.tail.Transform[P]])N[P[H] =&gt; sbt.KCons[H,KCons.this.tail.Transform[P],P]]">map</a><span class="delimiter">(</span><a href="#sbt;KCons.traverse.g" title="KCons.this.tail.Transform[P] =&gt; (P[H] =&gt; sbt.KCons[H,KCons.this.tail.Transform[P],P])">g</a>, <a href="#sbt;KCons.traverse.tt" title="N[KCons.this.tail.Transform[P]]">tt</a><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[P[H]]">f</a><span class="delimiter">(</span><a href="#sbt;KCons.head" title="=&gt; M[H]">head</a><span class="delimiter">)</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="keyword">def</span> <a title="[A, N[x] &gt;: M[x]](h: N[A])sbt.KCons[A,sbt.KCons[H,T,M],N]" id="sbt;KCons.:^:">:^:</a><span class="delimiter">[</span><a title="" id="sbt;KCons.:^:;A">A</a>,<a title="[x] &gt;: M[x]" id="sbt;KCons.:^:;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KCons.:^:;N;x">x</a><span class="delimiter">]</span> &gt;: M<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="N[A]" id="sbt;KCons.:^:.h">h</a>: <a href="#sbt;KCons.:^:;N" title="N[A]">N</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.KCons.readResolve" title="(head: N[A], tail: sbt.KCons[H,T,M])sbt.KCons[A,sbt.KCons[H,T,M],N]">KCons</a><span class="delimiter">(</span><a href="#sbt;KCons.:^:.h" title="N[A]">h</a>, <a href="#sbt.KCons.readResolve" title="sbt.KCons[H,T,M]" class="keyword">this</a><span class="delimiter">)</span>
	<span class="keyword">override</span> <span class="keyword">def</span> <a title="[T](f: (M[_], T) =&gt; T, init: T)T" id="sbt;KCons.foldr">foldr</a><span class="delimiter">[</span><a title="" id="sbt;KCons.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[_], T) =&gt; T" id="sbt;KCons.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt;KCons.foldr.init">init</a>: <a href="#sbt;KCons.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt;KCons.foldr;T" title="T">T</a> = <a href="#sbt;KCons.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt;KCons.head" title="=&gt; M[H]">head</a>, <a href="#sbt;KCons.tail" title="=&gt; T">tail</a>.<a href="#sbt;KList.foldr" title="(f: (M[_], T) =&gt; T, init: T)T">foldr</a><span class="delimiter">(</span><a href="#sbt;KCons.foldr.f" title="(M[_], T) =&gt; T">f</a>, <a href="#sbt;KCons.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class KNil extends AnyRef with sbt.KList[Nothing]" id="sbt;KNil">KNil</a> <a href="#sbt;KNil" title="sbt.KNil" class="keyword">extends</a> <a href="#sbt;KList" title="sbt.KList[Nothing]">KList</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span>
<span class="delimiter">{</span>
	<span class="keyword">final</span> <span class="keyword">type</span> <a title="[N[_]]sbt.KNil" id="sbt;KNil;Transform">Transform</a><span class="delimiter">[</span><a title="[_]" id="sbt;KNil;Transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KNil;Transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;KNil" title="sbt.KNil">KNil</a>
	<span class="keyword">final</span> <span class="keyword">def</span> <a title="[N[_]](f: sbt.~&gt;[Nothing,N])KNil.this.Transform[N]" id="sbt;KNil.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt;KNil.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KNil.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[Nothing,N]" id="sbt;KNil.transform.f">f</a>: Nothing <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Nothing,N]">~&gt;</a> N<span class="delimiter">)</span>: <a href="#sbt;KNil" title="KNil.this.Transform[N]">Transform</a><span class="delimiter">[</span>N<span class="delimiter">]</span> = <a href="#sbt.KNil.readResolve" title="sbt.KNil.type">KNil</a>
	<span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="sbt;KNil.toList">toList</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
	<span class="keyword">final</span> <span class="keyword">def</span> <a title="[N[x], Z](f: sbt.KNil =&gt; Z)(implicit ap: sbt.Classes.Applicative[N])N[Z]" id="sbt;KNil.apply">apply</a><span class="delimiter">[</span><a title="[x]" id="sbt;KNil.apply;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KNil.apply;N;x">x</a><span class="delimiter">]</span>, <a title="" id="sbt;KNil.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.KNil =&gt; Z" id="sbt;KNil.apply.f">f</a>: KNil =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt;KNil.apply.ap">ap</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;KNil.apply;N" title="N[Z]">N</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <a href="#sbt;KNil.apply.ap" title="sbt.Classes.Applicative[N]">ap</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.pure" title="(s: =&gt; Z)N[Z]">pure</a><span class="delimiter">(</span><a href="#sbt;KNil.apply.f" title="(v1: sbt.KNil)Z">f</a><span class="delimiter">(</span><a href="#sbt.KNil.readResolve" title="sbt.KNil.type">KNil</a><span class="delimiter">)</span><span class="delimiter">)</span>
	<span class="keyword">final</span> <span class="keyword">def</span> <a title="[N[_], P[_]](f: sbt.~&gt;[Nothing,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[sbt.KNil]" id="sbt;KNil.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt;KNil.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt;KNil.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;KNil.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt;KNil.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[Nothing,[T]N[P[T]]]" id="sbt;KNil.traverse.f">f</a>: Nothing <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Nothing,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N ∙ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt;KNil.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;KNil.traverse;N" title="N[sbt.KNil]">N</a><span class="delimiter">[</span>KNil<span class="delimiter">]</span> = <a href="#sbt;KNil.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.pure" title="(s: =&gt; sbt.KNil)N[sbt.KNil]">pure</a><span class="delimiter">(</span><a href="#sbt.KNil.readResolve" title="sbt.KNil.type">KNil</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="keyword">case object</span> <a href="#sbt.KNil.productElement.x$1" title="sbt.KNil.type" id="sbt.KNil.readResolve">KNil</a> <span title="Product" class="keyword">extends</span> <a href="#sbt;KNil" title="sbt.KNil">KNil</a> <span class="delimiter">{</span>
	<span class="keyword">def</span> <a title="[M[_], H](h: M[H])sbt.KCons[H,sbt.KNil,M]" id="sbt.KNil.:^:">:^:</a><span class="delimiter">[</span><a title="[_]" id="sbt.KNil.:^:;M">M</a><span class="delimiter">[</span><a title="" id="sbt.KNil.:^:;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.KNil.:^:;H">H</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[H]" id="sbt.KNil.:^:.h">h</a>: <a href="#sbt.KNil.:^:;M" title="M[H]">M</a><span class="delimiter">[</span>H<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.KCons.readResolve" title="sbt.KCons[H,sbt.KNil,M]">KCons</a><span class="delimiter">[</span>H, KNil, M<span class="delimiter">]</span> = <a href="#sbt.KCons.readResolve" title="(head: M[H], tail: sbt.KNil.type)sbt.KCons[H,sbt.KNil.type,M]">KCons</a><span class="delimiter">(</span><a href="#sbt.KNil.:^:.h" title="M[H]">h</a>, <span class="keyword">this</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
