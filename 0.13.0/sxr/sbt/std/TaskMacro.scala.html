<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/std/TaskMacro.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> std

	<span class="keyword">import</span> <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<span class="delimiter">{</span>Initialize,Setting<span class="delimiter">}</span>
	<span class="keyword">import</span> <a href="../Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>.<span class="delimiter">{</span>const, idFun,Id<span class="delimiter">}</span>
	<span class="keyword">import</span> <a href="TaskExtra.scala.html#sbt.std.TaskExtra" title="sbt.std.TaskExtra.type">TaskExtra</a>.allM
	<span class="keyword">import</span> appmacro.<span class="delimiter">{</span>ContextUtil, Convert, Converted, Instance, MixedBuilder, MonadInstance<span class="delimiter">}</span>
	<span class="keyword">import</span> <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.Transform
	<span class="keyword">import</span> complete.<span class="delimiter">{</span>DefaultParsers,Parser<span class="delimiter">}</span>

	<span class="keyword">import</span> <span title="language.type">language</span>.<span title="language.experimental.type">experimental</span>.macros
	<span class="keyword">import</span> scala.reflect._
	<span class="keyword">import</span> reflect.macros._
	<span class="keyword">import</span> reflect.internal.annotations.compileTimeOnly

<span class="comment">/** Instance for the monad/applicative functor for plain Tasks. */</span>
<span class="keyword">object</span> <a title="sbt.std.TaskInstance.type" id="sbt.std.TaskInstance">TaskInstance</a> <a href="#sbt.std.TaskInstance" title="sbt.std.TaskInstance.type" class="keyword">extends</a> <a href="../appmacro/Instance.scala.html#sbt.appmacro;MonadInstance" title="sbt.appmacro.MonadInstance">MonadInstance</a>
<span class="delimiter">{</span>
	<span class="keyword">import</span> <a href="TaskExtra.scala.html#sbt.std.TaskExtra" title="sbt.std.TaskExtra.type">TaskExtra</a>._

	<span class="keyword">final</span> <span class="keyword">type</span> <a title="[x]sbt.Task[x]" id="sbt.std.TaskInstance;M">M</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskInstance;M;x">x</a><span class="delimiter">]</span> = <a href="../Action.scala.html#sbt;Task" title="sbt.Task[x]">Task</a><span class="delimiter">[</span>x<span class="delimiter">]</span>
	<span class="keyword">def</span> <a title="[K[L[x]], Z](in: K[sbt.Task], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])sbt.Task[Z]" id="sbt.std.TaskInstance.app">app</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.std.TaskInstance.app;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.std.TaskInstance.app;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskInstance.app;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt.std.TaskInstance.app;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[sbt.Task]" id="sbt.std.TaskInstance.app.in">in</a>: <a href="#sbt.std.TaskInstance.app;K" title="K[sbt.Task]">K</a><span class="delimiter">[</span>Task<span class="delimiter">]</span>, <a title="K[sbt.Types.Id] =&gt; Z" id="sbt.std.TaskInstance.app.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[K]" id="sbt.std.TaskInstance.app.a">a</a>: <a href="../AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[Z]">Task</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <a href="../Action.scala.html#sbt;Task" title="(info: sbt.Info[Z], work: sbt.Action[Z])sbt.Task[Z]">Task</a><span class="delimiter">(</span><a href="../Action.scala.html#sbt;Info" title="(attributes: sbt.AttributeMap, post: Z =&gt; sbt.AttributeMap)sbt.Info[Z]">Info</a><span class="delimiter">(</span><span class="delimiter">)</span>, <span title="sbt.Mapped[Z,K]" class="keyword">new</span> <a href="../Action.scala.html#sbt;Mapped" title="sbt.Mapped[Z,K]">Mapped</a><span class="delimiter">[</span>Z,K<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskInstance.app.in" title="K[sbt.Task]">in</a>, <a href="#sbt.std.TaskInstance.app.f" title="K[sbt.Types.Id] =&gt; Z">f</a> <span title="(g: K[sbt.Result] =&gt; K[sbt.Types.Id])K[sbt.Result] =&gt; Z">compose</span> <a href="TaskExtra.scala.html#sbt.std.TaskExtra.allM" title="(implicit a: sbt.AList[K])K[sbt.Result] =&gt; K[sbt.Types.Id]">allM</a>, <a href="#sbt.std.TaskInstance.app.a" title="sbt.AList[K]">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[S, T](in: sbt.Task[S], f: S =&gt; T)sbt.Task[T]" id="sbt.std.TaskInstance.map">map</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskInstance.map;S">S</a>,<a title="" id="sbt.std.TaskInstance.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[S]" id="sbt.std.TaskInstance.map.in">in</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[S]">Task</a><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="S =&gt; T" id="sbt.std.TaskInstance.map.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="TaskExtra.scala.html#sbt.std;TaskExtra.singleInputTask" title="(in: sbt.Task[S])sbt.std.SingleInTask[S]">in</a> <a href="TaskExtra.scala.html#sbt.std;SingleInTask.map" title="(f: S =&gt; T)sbt.Task[T]">map</a> <a href="#sbt.std.TaskInstance.map.f" title="S =&gt; T">f</a>
	<span class="keyword">def</span> <a title="[T](in: sbt.Task[sbt.Task[T]])sbt.Task[T]" id="sbt.std.TaskInstance.flatten">flatten</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskInstance.flatten;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[sbt.Task[T]]" id="sbt.std.TaskInstance.flatten.in">in</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[sbt.Task[T]]">Task</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="TaskExtra.scala.html#sbt.std;TaskExtra.singleInputTask" title="(in: sbt.Task[sbt.Task[T]])sbt.std.SingleInTask[sbt.Task[T]]">in</a> <a href="TaskExtra.scala.html#sbt.std;SingleInTask.flatMap" title="(f: sbt.Task[T] =&gt; sbt.Task[T])sbt.Task[T]">flatMap</a> <a href="../TypeFunctions.scala.html#sbt;TypeFunctions.idFun" title="[T]=&gt; T =&gt; T">idFun</a><span title="sbt.Task[T] =&gt; sbt.Task[T]" class="delimiter">[</span><a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
	<span class="keyword">def</span> <a title="[T](t: () =&gt; T)sbt.Task[T]" id="sbt.std.TaskInstance.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskInstance.pure;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; T" id="sbt.std.TaskInstance.pure.t">t</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="TaskExtra.scala.html#sbt.std;TaskExtra.toTask" title="(f: () =&gt; T)sbt.Task[T]">toTask</a><span class="delimiter">(</span><a href="#sbt.std.TaskInstance.pure.t" title="() =&gt; T">t</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="keyword">object</span> <a title="sbt.std.ParserInstance.type" id="sbt.std.ParserInstance">ParserInstance</a> <a href="#sbt.std.ParserInstance" title="sbt.std.ParserInstance.type" class="keyword">extends</a> <a href="../appmacro/Instance.scala.html#sbt.appmacro;Instance" title="sbt.appmacro.Instance">Instance</a>
<span class="delimiter">{</span>
		<span class="keyword">import</span> sbt.<a href="../Classes.scala.html#sbt.Classes" title="sbt.Classes.type">Classes</a>.Applicative
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="sbt.Classes.Applicative[sbt.std.ParserInstance.M]" id="sbt.std.ParserInstance.parserApplicative">parserApplicative</a>: <a href="../Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[sbt.std.ParserInstance.M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span> = <a href="#sbt.std.ParserInstance.parserApplicative;$anon" title="sbt.Classes.Applicative[sbt.std.ParserInstance.M]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.Classes.Applicative[sbt.std.ParserInstance.M]" id="sbt.std.ParserInstance.parserApplicative;$anon">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">{</span>
		<span class="keyword">def</span> <a title="[S, T](f: sbt.State =&gt; sbt.complete.Parser[S =&gt; T], v: sbt.State =&gt; sbt.complete.Parser[S])sbt.State =&gt; sbt.complete.Parser[T]" id="sbt.std.ParserInstance.parserApplicative;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserInstance.parserApplicative;$anon.apply;S">S</a>,<a title="" id="sbt.std.ParserInstance.parserApplicative;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.State =&gt; sbt.complete.Parser[S =&gt; T]" id="sbt.std.ParserInstance.parserApplicative;$anon.apply.f">f</a>: <span title="sbt.State =&gt; sbt.complete.Parser[S =&gt; T]">M</span><span class="delimiter">[</span>S =&gt; T<span class="delimiter">]</span>, <a title="sbt.State =&gt; sbt.complete.Parser[S]" id="sbt.std.ParserInstance.parserApplicative;$anon.apply.v">v</a>: <span title="sbt.State =&gt; sbt.complete.Parser[S]">M</span><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="sbt.State =&gt; sbt.complete.Parser[T]">M</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a title="sbt.State" id="sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.s">s</a> =&gt; <span class="delimiter">(</span><a href="#sbt.std.ParserInstance.parserApplicative;$anon.apply.f" title="(v1: sbt.State)sbt.complete.Parser[S =&gt; T]">f</a><a href="../complete/Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[S =&gt; T])sbt.complete.RichParser[S =&gt; T]" class="delimiter">(</a><a href="#sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.s" title="sbt.State">s</a><span class="delimiter">)</span> <a href="../complete/Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(S =&gt; T, S)])sbt.complete.RichParser[(S =&gt; T, S)]">~</a> <a href="#sbt.std.ParserInstance.parserApplicative;$anon.apply.v" title="(v1: sbt.State)sbt.complete.Parser[S]">v</a><span class="delimiter">(</span><a href="#sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.s" title="sbt.State">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../complete/Parser.scala.html#sbt.complete;RichParser.map" title="(f: ((S =&gt; T, S)) =&gt; T)sbt.complete.Parser[T]">map</a> <a href="#sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.$anonfun.x0$1" title="T" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="S =&gt; T" id="sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.$anonfun.a">a</a>,<a title="S" id="sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <a href="#sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.$anonfun.a" title="(v1: S)T">a</a><span class="delimiter">(</span><a href="#sbt.std.ParserInstance.parserApplicative;$anon.apply.$anonfun.$anonfun.b" title="S">b</a><span class="delimiter">)</span> <span class="delimiter">}</span>
		<span class="keyword">def</span> <a title="[S](s: =&gt; S)sbt.State =&gt; sbt.complete.Parser[S]" id="sbt.std.ParserInstance.parserApplicative;$anon.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserInstance.parserApplicative;$anon.pure;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; S" id="sbt.std.ParserInstance.parserApplicative;$anon.pure.s">s</a>: =&gt; S<span class="delimiter">)</span> = <a href="../TypeFunctions.scala.html#sbt;TypeFunctions.const" title="(b: sbt.complete.Parser[S])sbt.State =&gt; sbt.complete.Parser[S]">const</a><span class="delimiter">(</span><a href="../complete/Parser.scala.html#sbt.complete.Parser" title="sbt.complete.Parser.type">Parser</a>.<a href="../complete/Parser.scala.html#sbt.complete;ParserMain.success" title="(value: S)sbt.complete.Parser[S]">success</a><span class="delimiter">(</span><a href="#sbt.std.ParserInstance.parserApplicative;$anon.pure.s" title="=&gt; S">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
		<span class="keyword">def</span> <a title="[S, T](f: S =&gt; T, v: sbt.State =&gt; sbt.complete.Parser[S])sbt.State =&gt; sbt.complete.Parser[T]" id="sbt.std.ParserInstance.parserApplicative;$anon.map">map</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserInstance.parserApplicative;$anon.map;S">S</a>, <a title="" id="sbt.std.ParserInstance.parserApplicative;$anon.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; T" id="sbt.std.ParserInstance.parserApplicative;$anon.map.f">f</a>: S =&gt; T, <a title="sbt.State =&gt; sbt.complete.Parser[S]" id="sbt.std.ParserInstance.parserApplicative;$anon.map.v">v</a>: <span title="sbt.State =&gt; sbt.complete.Parser[S]">M</span><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> = <a title="sbt.State" id="sbt.std.ParserInstance.parserApplicative;$anon.map.$anonfun.s">s</a> =&gt; <a href="#sbt.std.ParserInstance.parserApplicative;$anon.map.v" title="(v1: sbt.State)sbt.complete.Parser[S]">v</a><a href="../complete/Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[S])sbt.complete.RichParser[S]" class="delimiter">(</a><a href="#sbt.std.ParserInstance.parserApplicative;$anon.map.$anonfun.s" title="sbt.State">s</a><span class="delimiter">)</span>.<a href="../complete/Parser.scala.html#sbt.complete;RichParser.map" title="(f: S =&gt; T)sbt.complete.Parser[T]">map</a><span class="delimiter">(</span><a href="#sbt.std.ParserInstance.parserApplicative;$anon.map.f" title="S =&gt; T">f</a><span class="delimiter">)</span>
	<span class="delimiter">}</span>

	<span class="keyword">final</span> <span class="keyword">type</span> <a title="[x]sbt.State =&gt; sbt.complete.Parser[x]" id="sbt.std.ParserInstance;M">M</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserInstance;M;x">x</a><span class="delimiter">]</span> = State =&gt; Parser<span class="delimiter">[</span>x<span class="delimiter">]</span>
	<span class="keyword">def</span> <a title="[K[L[x]], Z](in: K[sbt.std.ParserInstance.M], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])sbt.State =&gt; sbt.complete.Parser[Z]" id="sbt.std.ParserInstance.app">app</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.std.ParserInstance.app;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.std.ParserInstance.app;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserInstance.app;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt.std.ParserInstance.app;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[sbt.std.ParserInstance.M]" id="sbt.std.ParserInstance.app.in">in</a>: <a href="#sbt.std.ParserInstance.app;K" title="K[sbt.std.ParserInstance.M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="K[sbt.Types.Id] =&gt; Z" id="sbt.std.ParserInstance.app.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[K]" id="sbt.std.ParserInstance.app.a">a</a>: <a href="../AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="sbt.State =&gt; sbt.complete.Parser[Z]">M</span><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <a href="#sbt.std.ParserInstance.app.a" title="sbt.AList[K]">a</a>.<a href="../AList.scala.html#sbt;AList.apply" title="(value: K[sbt.std.ParserInstance.M], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.Classes.Applicative[sbt.std.ParserInstance.M])sbt.State =&gt; sbt.complete.Parser[Z]">apply</a><a href="#sbt.std.ParserInstance.parserApplicative" title="sbt.Classes.Applicative[sbt.std.ParserInstance.M]" class="delimiter">(</a><a href="#sbt.std.ParserInstance.app.in" title="K[sbt.std.ParserInstance.M]">in</a>,<a href="#sbt.std.ParserInstance.app.f" title="K[sbt.Types.Id] =&gt; Z">f</a><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[S, T](in: sbt.State =&gt; sbt.complete.Parser[S], f: S =&gt; T)sbt.State =&gt; sbt.complete.Parser[T]" id="sbt.std.ParserInstance.map">map</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserInstance.map;S">S</a>,<a title="" id="sbt.std.ParserInstance.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.State =&gt; sbt.complete.Parser[S]" id="sbt.std.ParserInstance.map.in">in</a>: <span title="sbt.State =&gt; sbt.complete.Parser[S]">M</span><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="S =&gt; T" id="sbt.std.ParserInstance.map.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <span title="sbt.State =&gt; sbt.complete.Parser[T]">M</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a title="sbt.State" id="sbt.std.ParserInstance.map.$anonfun.s">s</a> =&gt; <a href="#sbt.std.ParserInstance.map.in" title="(v1: sbt.State)sbt.complete.Parser[S]">in</a><a href="../complete/Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[S])sbt.complete.RichParser[S]" class="delimiter">(</a><a href="#sbt.std.ParserInstance.map.$anonfun.s" title="sbt.State">s</a><span class="delimiter">)</span> <a href="../complete/Parser.scala.html#sbt.complete;RichParser.map" title="(f: S =&gt; T)sbt.complete.Parser[T]">map</a> <a href="#sbt.std.ParserInstance.map.f" title="S =&gt; T">f</a>
	<span class="keyword">def</span> <a title="[T](t: () =&gt; T)sbt.State =&gt; sbt.complete.Parser[T]" id="sbt.std.ParserInstance.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserInstance.pure;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; T" id="sbt.std.ParserInstance.pure.t">t</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: State =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="../TypeFunctions.scala.html#sbt;TypeFunctions.const" title="(b: sbt.complete.Parser[T])sbt.State =&gt; sbt.complete.Parser[T]">const</a><span class="delimiter">(</span><a href="../complete/Parsers.scala.html#sbt.complete.DefaultParsers" title="sbt.complete.DefaultParsers.type">DefaultParsers</a>.<a href="../complete/Parser.scala.html#sbt.complete;ParserMain.success" title="(value: T)sbt.complete.Parser[T]">success</a><span class="delimiter">(</span><a href="#sbt.std.ParserInstance.pure.t" title="()T">t</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/** Composes the Task and Initialize Instances to provide an Instance for [T] Initialize[Task[T]].*/</span>
<span class="keyword">object</span> <a title="sbt.std.FullInstance.type" id="sbt.std.FullInstance">FullInstance</a> <a href="#sbt.std.FullInstance" title="sbt.std.FullInstance.type" class="keyword">extends</a> Instance.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance;Composed" title="sbt.appmacro.Instance.Composed[sbt.Def.Initialize,sbt.Task]">Composed</a><span class="delimiter">[</span>Initialize, Task<span class="delimiter">]</span><span class="delimiter">(</span><a href="SettingMacro.scala.html#sbt.std.InitializeInstance" title="sbt.std.InitializeInstance.type">InitializeInstance</a>, <a href="#sbt.std.TaskInstance" title="sbt.std.TaskInstance.type">TaskInstance</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="../appmacro/Instance.scala.html#sbt.appmacro;MonadInstance" title="sbt.appmacro.MonadInstance">MonadInstance</a>
<span class="delimiter">{</span>
	<span class="keyword">type</span> <a title="sbt.Settings[sbt.Scope]" id="sbt.std.FullInstance;SS">SS</a> = sbt.<a href="../Settings.scala.html#sbt;Settings" title="sbt.Settings[sbt.Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span>
	<span class="keyword">val</span> <a title="sbt.TaskKey[sbt.std.FullInstance.SS]" id="sbt.std.FullInstance.settingsData">settingsData</a> = <a href="../Structure.scala.html#sbt.TaskKey.apply(f1c4babf5a)" title="[T](label: String, description: String, rank: Int)(implicit evidence$4: Manifest[T])sbt.TaskKey[T]">TaskKey</a><span title="(label: String, description: String, rank: Int)(implicit evidence$4: Manifest[sbt.std.FullInstance.SS])sbt.TaskKey[sbt.std.FullInstance.SS]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Settings" title="sbt.std.FullInstance.SS">SS</a><span class="delimiter">]</span><span title="(clazz: Class[sbt.std.FullInstance.SS], arg1: scala.reflect.Manifest[_], args: scala.reflect.Manifest[_]*)scala.reflect.Manifest[sbt.std.FullInstance.SS]" class="delimiter">(</span><span title="String(&quot;settings-data&quot;)" class="string">&quot;settings-data&quot;</span>, <span title="String(&quot;Provides access to the project data for the build.&quot;)" class="string">&quot;Provides access to the project data for the build.&quot;</span>, KeyRanks.<span title="Int(20000)">DTask</span><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[T](in: sbt.Def.Initialize[sbt.Task[sbt.Def.Initialize[sbt.Task[T]]]])sbt.Def.Initialize[sbt.Task[T]]" id="sbt.std.FullInstance.flatten">flatten</a><span class="delimiter">[</span><a title="" id="sbt.std.FullInstance.flatten;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Def.Initialize[sbt.Task[sbt.Def.Initialize[sbt.Task[T]]]]" id="sbt.std.FullInstance.flatten.in">in</a>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.Task[sbt.Def.Initialize[sbt.Task[T]]]]">Initialize</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.Task[T]]">Initialize</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="../Structure.scala.html#sbt.Scoped" title="sbt.Scoped.type">Scoped</a>._
		<a href="../Structure.scala.html#sbt.Scoped.t3ToApp3" title="(t3: (sbt.Def.Initialize[sbt.Task[sbt.Def.Initialize[sbt.Task[T]]]], sbt.Def.Initialize[sbt.Task[sbt.std.FullInstance.SS]], sbt.Def.Initialize[sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]]))sbt.Scoped.Apply3[sbt.Task[sbt.Def.Initialize[sbt.Task[T]]],sbt.Task[sbt.std.FullInstance.SS],sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]]" class="delimiter">(</a><a href="#sbt.std.FullInstance.flatten.in" title="sbt.Def.Initialize[sbt.Task[sbt.Def.Initialize[sbt.Task[T]]]]">in</a>,<a href="#sbt.std.FullInstance.settingsData" title="=&gt; sbt.TaskKey[sbt.std.FullInstance.SS]">settingsData</a>, <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.capturedTransformations" title="=&gt; sbt.Def.Initialize[sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]]">capturedTransformations</a><span class="delimiter">)</span> <a href="../Structure.scala.html#sbt.Scoped;Apply3.apply" title="(z: (sbt.Task[sbt.Def.Initialize[sbt.Task[T]]], sbt.Task[sbt.std.FullInstance.SS], sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]) =&gt; sbt.Task[T])sbt.Def.Initialize[sbt.Task[T]]">apply</a><span class="delimiter">{</span>
			<span class="delimiter">(</span>a: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[sbt.Def.Initialize[sbt.Task[T]]]">Task</a><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>, data: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[sbt.std.FullInstance.SS]">Task</a><span class="delimiter">[</span>SS<span class="delimiter">]</span>, <a title="sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]" id="sbt.std.FullInstance.flatten.$anonfun.f">f</a><span class="delimiter">)</span> =&gt;
				<span class="keyword">import</span> <a href="TaskExtra.scala.html#sbt.std.TaskExtra" title="sbt.std.TaskExtra.type">TaskExtra</a>.multT2Task
				<a href="TaskExtra.scala.html#sbt.std;TaskExtra.multT2Task" title="(in: (sbt.Task[sbt.Def.Initialize[sbt.Task[T]]], sbt.Task[sbt.std.FullInstance.SS]))sbt.std.MultiInTask[[L[x]](L[sbt.Def.Initialize[sbt.Task[T]]], L[sbt.std.FullInstance.SS])]" class="delimiter">(</a><a href="#sbt.std.FullInstance.flatten.$anonfun.a" title="sbt.Task[sbt.Def.Initialize[sbt.Task[T]]]">a</a>, <a href="#sbt.std.FullInstance.flatten.$anonfun.data" title="sbt.Task[sbt.std.FullInstance.SS]">data</a><span class="delimiter">)</span> <a href="TaskExtra.scala.html#sbt.std;MultiInTask.flatMap" title="(f: ((sbt.Types.Id[sbt.Def.Initialize[sbt.Task[T]]], sbt.Types.Id[sbt.std.FullInstance.SS])) =&gt; sbt.Task[T])sbt.Task[T]">flatMap</a> <a href="#sbt.std.FullInstance.flatten.$anonfun.$anonfun.x0$2" title="sbt.Task[T]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="sbt.Types.Id[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.FullInstance.flatten.$anonfun.$anonfun.a">a</a>,<a title="sbt.Types.Id[sbt.std.FullInstance.SS]" id="sbt.std.FullInstance.flatten.$anonfun.$anonfun.d">d</a><span class="delimiter">)</span> =&gt; <a href="../TypeFunctions.scala.html#sbt;~>.apply" title="(a: sbt.Def.Initialize[sbt.Task[T]])sbt.Def.Initialize[sbt.Task[T]]">f</a><span class="delimiter">(</span><a href="#sbt.std.FullInstance.flatten.$anonfun.$anonfun.a" title="sbt.Types.Id[sbt.Def.Initialize[sbt.Task[T]]]">a</a><span class="delimiter">)</span> <a href="../Settings.scala.html#sbt;Init;Initialize.evaluate" title="(map: sbt.Settings[sbt.Scope])sbt.Task[T]">evaluate</a> <a href="#sbt.std.FullInstance.flatten.$anonfun.$anonfun.d" title="sbt.Types.Id[sbt.std.FullInstance.SS]">d</a> <span class="delimiter">}</span>
		<span class="delimiter">}</span>
	<span class="delimiter">}</span>
	<span class="keyword">def</span> <a title="[S, T](in: sbt.Def.Initialize[sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]]])sbt.Def.Initialize[S =&gt; sbt.Task[T]]" id="sbt.std.FullInstance.flattenFun">flattenFun</a><span class="delimiter">[</span><a title="" id="sbt.std.FullInstance.flattenFun;S">S</a>,<a title="" id="sbt.std.FullInstance.flattenFun;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Def.Initialize[sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]]]" id="sbt.std.FullInstance.flattenFun.in">in</a>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]]]">Initialize</a><span class="delimiter">[</span>Task<span class="delimiter">[</span> S =&gt; Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[S =&gt; sbt.Task[T]]">Initialize</a><span class="delimiter">[</span>S =&gt; Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="../Structure.scala.html#sbt.Scoped" title="sbt.Scoped.type">Scoped</a>._
		<a href="../Structure.scala.html#sbt.Scoped.t3ToApp3" title="(t3: (sbt.Def.Initialize[sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]]], sbt.Def.Initialize[sbt.Task[sbt.std.FullInstance.SS]], sbt.Def.Initialize[sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]]))sbt.Scoped.Apply3[sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]],sbt.Task[sbt.std.FullInstance.SS],sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]]" class="delimiter">(</a><a href="#sbt.std.FullInstance.flattenFun.in" title="sbt.Def.Initialize[sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]]]">in</a>,<a href="#sbt.std.FullInstance.settingsData" title="=&gt; sbt.TaskKey[sbt.std.FullInstance.SS]">settingsData</a>, <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.capturedTransformations" title="=&gt; sbt.Def.Initialize[sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]]">capturedTransformations</a><span class="delimiter">)</span> <a href="../Structure.scala.html#sbt.Scoped;Apply3.apply" title="(z: (sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]], sbt.Task[sbt.std.FullInstance.SS], sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]) =&gt; S =&gt; sbt.Task[T])sbt.Def.Initialize[S =&gt; sbt.Task[T]]">apply</a><span class="delimiter">{</span>
			<span class="delimiter">(</span>a: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]]">Task</a><span class="delimiter">[</span>S =&gt; Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>, data: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[sbt.std.FullInstance.SS]">Task</a><span class="delimiter">[</span>SS<span class="delimiter">]</span>, <a title="sbt.~&gt;[sbt.Def.Initialize,sbt.Def.Initialize]" id="sbt.std.FullInstance.flattenFun.$anonfun.f">f</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>s: <a href="#sbt.std.FullInstance.flattenFun;S" title="S">S</a><span class="delimiter">)</span> =&gt;
				<span class="keyword">import</span> <a href="TaskExtra.scala.html#sbt.std.TaskExtra" title="sbt.std.TaskExtra.type">TaskExtra</a>.multT2Task
				<a href="TaskExtra.scala.html#sbt.std;TaskExtra.multT2Task" title="(in: (sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]], sbt.Task[sbt.std.FullInstance.SS]))sbt.std.MultiInTask[[L[x]](L[S =&gt; sbt.Def.Initialize[sbt.Task[T]]], L[sbt.std.FullInstance.SS])]" class="delimiter">(</a><a href="#sbt.std.FullInstance.flattenFun.$anonfun.a" title="sbt.Task[S =&gt; sbt.Def.Initialize[sbt.Task[T]]]">a</a>, <a href="#sbt.std.FullInstance.flattenFun.$anonfun.data" title="sbt.Task[sbt.std.FullInstance.SS]">data</a><span class="delimiter">)</span> <a href="TaskExtra.scala.html#sbt.std;MultiInTask.flatMap" title="(f: ((S =&gt; sbt.Def.Initialize[sbt.Task[T]], sbt.Types.Id[sbt.std.FullInstance.SS])) =&gt; sbt.Task[T])sbt.Task[T]">flatMap</a> <a href="#sbt.std.FullInstance.flattenFun.$anonfun.$anonfun.$anonfun.x0$3" title="sbt.Task[T]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="S =&gt; sbt.Def.Initialize[sbt.Task[T]]" id="sbt.std.FullInstance.flattenFun.$anonfun.$anonfun.$anonfun.af">af</a>,<a title="sbt.Types.Id[sbt.std.FullInstance.SS]" id="sbt.std.FullInstance.flattenFun.$anonfun.$anonfun.$anonfun.d">d</a><span class="delimiter">)</span> =&gt; <a href="../TypeFunctions.scala.html#sbt;~>.apply" title="(a: sbt.Def.Initialize[sbt.Task[T]])sbt.Def.Initialize[sbt.Task[T]]">f</a><span class="delimiter">(</span><a href="#sbt.std.FullInstance.flattenFun.$anonfun.$anonfun.$anonfun.af" title="(v1: S)sbt.Def.Initialize[sbt.Task[T]]">af</a><span class="delimiter">(</span><a href="#sbt.std.FullInstance.flattenFun.$anonfun.$anonfun.s" title="S">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../Settings.scala.html#sbt;Init;Initialize.evaluate" title="(map: sbt.Settings[sbt.Scope])sbt.Task[T]">evaluate</a> <a href="#sbt.std.FullInstance.flattenFun.$anonfun.$anonfun.$anonfun.d" title="sbt.Types.Id[sbt.std.FullInstance.SS]">d</a> <span class="delimiter">}</span>
		<span class="delimiter">}</span>
	<span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="sbt.std.TaskMacro.type" id="sbt.std.TaskMacro">TaskMacro</a>
<a href="#sbt.std.TaskMacro" title="sbt.std.TaskMacro.type" class="delimiter">{</a>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;set&quot;)" id="sbt.std.TaskMacro.AssignInitName">AssignInitName</a> = <span title="String(&quot;set&quot;)" class="string">&quot;set&quot;</span>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;append1&quot;)" id="sbt.std.TaskMacro.Append1InitName">Append1InitName</a> = <span title="String(&quot;append1&quot;)" class="string">&quot;append1&quot;</span>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;appendN&quot;)" id="sbt.std.TaskMacro.AppendNInitName">AppendNInitName</a> = <span title="String(&quot;appendN&quot;)" class="string">&quot;appendN&quot;</span>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;transform&quot;)" id="sbt.std.TaskMacro.TransformInitName">TransformInitName</a> = <span title="String(&quot;transform&quot;)" class="string">&quot;transform&quot;</span>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;createDyn&quot;)" id="sbt.std.TaskMacro.InputTaskCreateDynName">InputTaskCreateDynName</a> = <span title="String(&quot;createDyn&quot;)" class="string">&quot;createDyn&quot;</span>
	<span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;createFree&quot;)" id="sbt.std.TaskMacro.InputTaskCreateFreeName">InputTaskCreateFreeName</a> = <span title="String(&quot;createFree&quot;)" class="string">&quot;createFree&quot;</span>

	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskMacroImpl">taskMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.taskMacroImpl.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = 
		<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[sbt.Types.Id[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[sbt.Types.Id[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.taskMacroImpl;T" title="T">T</a>,<a href="../TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskMacroImpl.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.FullInstance" title="sbt.std.FullInstance.type">FullInstance</a>, <a href="InputConvert.scala.html#sbt.std.FullConvert" title="sbt.std.FullConvert.type">FullConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.taskMacroImpl.evidence$1" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(a: c.Expr[T])scala.util.Left[c.Expr[T],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskMacroImpl.t" title="c.Expr[T]">t</a><span class="delimiter">)</span>, <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.idTransform" title="[C &lt;: scala.reflect.macros.Context with Singleton]=&gt; sbt.appmacro.Instance.Transform[C,sbt.Types.Id]">idTransform</a><span title="sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$2: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskDynMacroImpl">taskDynMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskDynMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskDynMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskDynMacroImpl.t">t</a>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = 
		<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[sbt.Types.Id[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[sbt.Types.Id[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.taskDynMacroImpl;T" title="T">T</a>,<a href="../TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskDynMacroImpl.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.FullInstance" title="sbt.std.FullInstance.type">FullInstance</a>, <a href="InputConvert.scala.html#sbt.std.FullConvert" title="sbt.std.FullConvert.type">FullConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.taskDynMacroImpl.evidence$2" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(b: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])scala.util.Right[Nothing,c.Expr[sbt.Def.Initialize[sbt.Task[T]]]]">Right</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskDynMacroImpl.t" title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">t</a><span class="delimiter">)</span>, <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.idTransform" title="[C &lt;: scala.reflect.macros.Context with Singleton]=&gt; sbt.appmacro.Instance.Transform[C,sbt.Types.Id]">idTransform</a><span title="sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>

	<span class="comment">/** Implementation of := macro for settings. */</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(v: c.Expr[T])(implicit evidence$3: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[T]]" id="sbt.std.TaskMacro.settingAssignMacroImpl">settingAssignMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingAssignMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingAssignMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.settingAssignMacroImpl.v">v</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[T]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[T]]" id="sbt.std.TaskMacro.settingAssignMacroImpl.init">init</a> = <a href="SettingMacro.scala.html#sbt.std.SettingMacro" title="sbt.std.SettingMacro.type">SettingMacro</a>.<a href="SettingMacro.scala.html#sbt.std.SettingMacro.settingMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$2: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[T]]">settingMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$2: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[T]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.settingAssignMacroImpl;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.settingAssignMacroImpl.evidence$3" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.settingAssignMacroImpl.v" title="c.Expr[T]">v</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.settingAssignMacroImpl.assign">assign</a> = <a href="#sbt.std.TaskMacro.transformMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree">transformMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.settingAssignMacroImpl.init" title="c.Expr[sbt.Def.Initialize[T]]">init</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;set&quot;)">AssignInitName</span> <span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.settingAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[T]])c.Expr[sbt.Def.Setting[T]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.settingAssignMacroImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[T]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.settingAssignMacroImpl.assign" title="c.Tree">assign</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="comment">/** Implementation of := macro for tasks. */</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(v: c.Expr[T])(implicit evidence$4: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskAssignMacroImpl">taskAssignMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskAssignMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskAssignMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.taskAssignMacroImpl.v">v</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskAssignMacroImpl.init">init</a> = <a href="#sbt.std.TaskMacro.taskMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">taskMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.taskAssignMacroImpl;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.taskAssignMacroImpl.evidence$4" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.taskAssignMacroImpl.v" title="c.Expr[T]">v</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.taskAssignMacroImpl.assign">assign</a> = <a href="#sbt.std.TaskMacro.transformMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree">transformMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.taskAssignMacroImpl.init" title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">init</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;set&quot;)">AssignInitName</span> <span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.taskAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[sbt.Task[T]]])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[sbt.Task[T]]">Setting</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.taskAssignMacroImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[sbt.Task[T]]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.taskAssignMacroImpl.assign" title="c.Tree">assign</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>

	<span class="comment">/* Implementations of &lt;&lt;= macro variations for tasks and settings. These just get the source position of the call site.*/</span>

	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(app: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$5: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" id="sbt.std.TaskMacro.itaskAssignPosition">itaskAssignPosition</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.itaskAssignPosition;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.itaskAssignPosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.itaskAssignPosition.app">app</a>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.settingAssignPosition" title="(c: scala.reflect.macros.Context)(app: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$20: c.WeakTypeTag[sbt.Task[T]])c.Expr[sbt.Def.Setting[sbt.Task[T]]]">settingAssignPosition</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.itaskAssignPosition.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.itaskAssignPosition.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Task[T]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.itaskAssignPosition.app" title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">app</a><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(app: c.Expr[sbt.Task[T]])(implicit evidence$6: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskAssignPositionT">taskAssignPositionT</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskAssignPositionT;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskAssignPositionT.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Task[T]]" id="sbt.std.TaskMacro.taskAssignPositionT.app">app</a>: c.<span title="c.Expr[sbt.Task[T]]">Expr</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.itaskAssignPosition" title="(c: scala.reflect.macros.Context)(app: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$5: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[sbt.Task[T]]]">itaskAssignPosition</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAssignPositionT.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.taskAssignPositionT.evidence$6" title="c.WeakTypeTag[T]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.taskAssignPositionT.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.Def.Initialize[sbt.Task[T]])c.universe.Expr[sbt.Def.Initialize[sbt.Task[T]]]">reify</span> <span class="delimiter">{</span> <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.valueStrict" title="(value: sbt.Task[T])sbt.Def.Initialize[sbt.Task[T]]">valueStrict</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAssignPositionT.app" title="c.Expr[sbt.Task[T]]">app</a>.<span title="=&gt; sbt.Task[T]">splice</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(app: c.Expr[T])(implicit evidence$7: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskAssignPositionPure">taskAssignPositionPure</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskAssignPositionPure;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskAssignPositionPure.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.taskAssignPositionPure.app">app</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.taskAssignPositionT" title="(c: scala.reflect.macros.Context)(app: c.Expr[sbt.Task[T]])(implicit evidence$6: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[sbt.Task[T]]]">taskAssignPositionT</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAssignPositionPure.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.taskAssignPositionPure.evidence$7" title="c.WeakTypeTag[T]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.taskAssignPositionPure.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.Task[T])c.universe.Expr[sbt.Task[T]]">reify</span> <span class="delimiter">{</span> <a href="TaskExtra.scala.html#sbt.std.TaskExtra" title="sbt.std.TaskExtra.type">TaskExtra</a>.<a href="TaskExtra.scala.html#sbt.std;TaskExtra.constant" title="(t: T)sbt.Task[T]">constant</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAssignPositionPure.app" title="c.Expr[T]">app</a>.<span title="=&gt; T">splice</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[S](c: scala.reflect.macros.Context)(f: c.Expr[S =&gt; S])(implicit evidence$8: c.WeakTypeTag[S])c.Expr[sbt.Def.Setting[sbt.Task[S]]]" id="sbt.std.TaskMacro.taskTransformPosition">taskTransformPosition</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskTransformPosition;S">S</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskTransformPosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[S =&gt; S]" id="sbt.std.TaskMacro.taskTransformPosition.f">f</a>: c.<span title="c.Expr[S =&gt; S]">Expr</span><span class="delimiter">[</span>S =&gt; S<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[S]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.taskTransformPosition.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[sbt.Task[S]]])c.Expr[sbt.Def.Setting[sbt.Task[S]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[sbt.Task[S]]">Setting</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.taskTransformPosition.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[sbt.Task[S]]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.transformMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree">transformMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskTransformPosition.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.taskTransformPosition.f" title="c.Expr[S =&gt; S]">f</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;transform&quot;)">TransformInitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[S](c: scala.reflect.macros.Context)(f: c.Expr[S =&gt; S])(implicit evidence$9: c.WeakTypeTag[S])c.Expr[sbt.Def.Setting[S]]" id="sbt.std.TaskMacro.settingTransformPosition">settingTransformPosition</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingTransformPosition;S">S</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingTransformPosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[S =&gt; S]" id="sbt.std.TaskMacro.settingTransformPosition.f">f</a>: c.<span title="c.Expr[S =&gt; S]">Expr</span><span class="delimiter">[</span>S =&gt; S<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[S]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.settingTransformPosition.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[S]])c.Expr[sbt.Def.Setting[S]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[S]">Setting</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.settingTransformPosition.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[S]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.transformMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree">transformMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingTransformPosition.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.settingTransformPosition.f" title="c.Expr[S =&gt; S]">f</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;transform&quot;)">TransformInitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[S](c: scala.reflect.macros.Context)(f: c.Expr[S =&gt; S])(implicit evidence$10: c.WeakTypeTag[S])c.Expr[sbt.Def.Setting[S]]" id="sbt.std.TaskMacro.itaskTransformPosition">itaskTransformPosition</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.itaskTransformPosition;S">S</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.itaskTransformPosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[S =&gt; S]" id="sbt.std.TaskMacro.itaskTransformPosition.f">f</a>: c.<span title="c.Expr[S =&gt; S]">Expr</span><span class="delimiter">[</span>S =&gt; S<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[S]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.itaskTransformPosition.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[S]])c.Expr[sbt.Def.Setting[S]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[S]">Setting</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.itaskTransformPosition.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[S]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.transformMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree">transformMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.itaskTransformPosition.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.itaskTransformPosition.f" title="c.Expr[S =&gt; S]">f</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;transform&quot;)">TransformInitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>


	<span class="keyword">def</span> <a title="[S, V](c: scala.reflect.macros.Context)(vs: c.Expr[sbt.Def.Initialize[sbt.Task[V]]])(a: c.Expr[sbt.Append.Values[S,V]])(implicit evidence$11: c.WeakTypeTag[S], implicit evidence$12: c.WeakTypeTag[V])c.Expr[sbt.Def.Setting[sbt.Task[S]]]" id="sbt.std.TaskMacro.taskAppendNPosition">taskAppendNPosition</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskAppendNPosition;S">S</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.taskAppendNPosition;V">V</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskAppendNPosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[sbt.Task[V]]]" id="sbt.std.TaskMacro.taskAppendNPosition.vs">vs</a>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[V]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Values[S,V]]" id="sbt.std.TaskMacro.taskAppendNPosition.a">a</a>: c.<span title="c.Expr[sbt.Append.Values[S,V]]">Expr</span><span class="delimiter">[</span>Append.Values<span class="delimiter">[</span>S, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[S]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.taskAppendNPosition.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[sbt.Task[S]]])c.Expr[sbt.Def.Setting[sbt.Task[S]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[sbt.Task[S]]">Setting</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.taskAppendNPosition.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[sbt.Task[S]]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAppendNPosition.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.taskAppendNPosition.vs" title="c.Expr[sbt.Def.Initialize[sbt.Task[V]]]">vs</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.taskAppendNPosition.a" title="c.Expr[sbt.Append.Values[S,V]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;appendN&quot;)">AppendNInitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[S, V](c: scala.reflect.macros.Context)(vs: c.Expr[sbt.Def.Initialize[V]])(a: c.Expr[sbt.Append.Values[S,V]])(implicit evidence$13: c.WeakTypeTag[S], implicit evidence$14: c.WeakTypeTag[V])c.Expr[sbt.Def.Setting[S]]" id="sbt.std.TaskMacro.settingAppendNPosition">settingAppendNPosition</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingAppendNPosition;S">S</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.settingAppendNPosition;V">V</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingAppendNPosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[V]]" id="sbt.std.TaskMacro.settingAppendNPosition.vs">vs</a>: c.<span title="c.Expr[sbt.Def.Initialize[V]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Values[S,V]]" id="sbt.std.TaskMacro.settingAppendNPosition.a">a</a>: c.<span title="c.Expr[sbt.Append.Values[S,V]]">Expr</span><span class="delimiter">[</span>Append.Values<span class="delimiter">[</span>S, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[S]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.settingAppendNPosition.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[S]])c.Expr[sbt.Def.Setting[S]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[S]">Setting</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.settingAppendNPosition.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[S]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAppendNPosition.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.settingAppendNPosition.vs" title="c.Expr[sbt.Def.Initialize[V]]">vs</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.settingAppendNPosition.a" title="c.Expr[sbt.Append.Values[S,V]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;appendN&quot;)">AppendNInitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[S, V](c: scala.reflect.macros.Context)(v: c.Expr[sbt.Def.Initialize[sbt.Task[V]]])(a: c.Expr[sbt.Append.Value[S,V]])(implicit evidence$15: c.WeakTypeTag[S], implicit evidence$16: c.WeakTypeTag[V])c.Expr[sbt.Def.Setting[sbt.Task[S]]]" id="sbt.std.TaskMacro.taskAppend1Position">taskAppend1Position</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskAppend1Position;S">S</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.taskAppend1Position;V">V</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskAppend1Position.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[sbt.Task[V]]]" id="sbt.std.TaskMacro.taskAppend1Position.v">v</a>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[V]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Value[S,V]]" id="sbt.std.TaskMacro.taskAppend1Position.a">a</a>: c.<span title="c.Expr[sbt.Append.Value[S,V]]">Expr</span><span class="delimiter">[</span>Append.Value<span class="delimiter">[</span>S, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[S]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.taskAppend1Position.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[sbt.Task[S]]])c.Expr[sbt.Def.Setting[sbt.Task[S]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[sbt.Task[S]]">Setting</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.taskAppend1Position.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[sbt.Task[S]]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAppend1Position.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.taskAppend1Position.v" title="c.Expr[sbt.Def.Initialize[sbt.Task[V]]]">v</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.taskAppend1Position.a" title="c.Expr[sbt.Append.Value[S,V]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;append1&quot;)">Append1InitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[S, V](c: scala.reflect.macros.Context)(v: c.Expr[sbt.Def.Initialize[V]])(a: c.Expr[sbt.Append.Value[S,V]])(implicit evidence$17: c.WeakTypeTag[S], implicit evidence$18: c.WeakTypeTag[V])c.Expr[sbt.Def.Setting[S]]" id="sbt.std.TaskMacro.settingAppend1Position">settingAppend1Position</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingAppend1Position;S">S</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.settingAppend1Position;V">V</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingAppend1Position.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[V]]" id="sbt.std.TaskMacro.settingAppend1Position.v">v</a>: c.<span title="c.Expr[sbt.Def.Initialize[V]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Value[S,V]]" id="sbt.std.TaskMacro.settingAppend1Position.a">a</a>: c.<span title="c.Expr[sbt.Append.Value[S,V]]">Expr</span><span class="delimiter">[</span>Append.Value<span class="delimiter">[</span>S, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[S]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.settingAppend1Position.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[S]])c.Expr[sbt.Def.Setting[S]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[S]">Setting</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.settingAppend1Position.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[S]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAppend1Position.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.settingAppend1Position.v" title="c.Expr[sbt.Def.Initialize[V]]">v</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.settingAppend1Position.a" title="c.Expr[sbt.Append.Value[S,V]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;append1&quot;)">Append1InitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(app: c.Expr[T])(implicit evidence$19: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[T]]" id="sbt.std.TaskMacro.settingAssignPure">settingAssignPure</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingAssignPure;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingAssignPure.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.settingAssignPure.app">app</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[T]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.settingAssignPosition" title="(c: scala.reflect.macros.Context)(app: c.Expr[sbt.Def.Initialize[T]])(implicit evidence$20: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[T]]">settingAssignPosition</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAssignPure.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.settingAssignPure.evidence$19" title="c.WeakTypeTag[T]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.settingAssignPure.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.Def.Initialize[T])c.universe.Expr[sbt.Def.Initialize[T]]">reify</span> <span class="delimiter">{</span> <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.valueStrict" title="(value: T)sbt.Def.Initialize[T]">valueStrict</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAssignPure.app" title="c.Expr[T]">app</a>.<span title="=&gt; T">splice</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(app: c.Expr[sbt.Def.Initialize[T]])(implicit evidence$20: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[T]]" id="sbt.std.TaskMacro.settingAssignPosition">settingAssignPosition</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingAssignPosition;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingAssignPosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[T]]" id="sbt.std.TaskMacro.settingAssignPosition.app">app</a>: c.<span title="c.Expr[sbt.Def.Initialize[T]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[T]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.settingAssignPosition.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[T]])c.Expr[sbt.Def.Setting[T]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.settingAssignPosition.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[T]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.transformMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree">transformMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAssignPosition.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.settingAssignPosition.app" title="c.Expr[sbt.Def.Initialize[T]]">app</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;set&quot;)">AssignInitName</span> <span class="delimiter">)</span> <span class="delimiter">)</span>

	<span class="comment">/** Implementation of := macro for tasks. */</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(v: c.Expr[T])(implicit evidence$21: c.WeakTypeTag[T])c.Expr[sbt.Def.Setting[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskAssignMacroImpl">inputTaskAssignMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.inputTaskAssignMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.inputTaskAssignMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.inputTaskAssignMacroImpl.v">v</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.InputTask[T]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskAssignMacroImpl.init">init</a> = <a href="#sbt.std.TaskMacro.inputTaskMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$31: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">inputTaskMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$31: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.evidence$21" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.v" title="c.Expr[T]">v</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.inputTaskAssignMacroImpl.assign">assign</a> = <a href="#sbt.std.TaskMacro.transformMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree">transformMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.init" title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">init</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;set&quot;)">AssignInitName</span> <span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[sbt.InputTask[T]]])c.Expr[sbt.Def.Setting[sbt.InputTask[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[sbt.InputTask[T]]">Setting</a><span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[sbt.InputTask[T]]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.inputTaskAssignMacroImpl.assign" title="c.Tree">assign</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="comment">/** Implementation of += macro for tasks. */</span>
	<span class="keyword">def</span> <a title="[T, U](c: scala.reflect.macros.Context)(v: c.Expr[U])(a: c.Expr[sbt.Append.Value[T,U]])(implicit evidence$22: c.WeakTypeTag[T], implicit evidence$23: c.WeakTypeTag[U])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskAppend1Impl">taskAppend1Impl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskAppend1Impl;T">T</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.taskAppend1Impl;U">U</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskAppend1Impl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[U]" id="sbt.std.TaskMacro.taskAppend1Impl.v">v</a>: c.<span title="c.Expr[U]">Expr</span><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Value[T,U]]" id="sbt.std.TaskMacro.taskAppend1Impl.a">a</a>: c.<span title="c.Expr[sbt.Append.Value[T,U]]">Expr</span><span class="delimiter">[</span>Append.Value<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[sbt.Task[U]]]" id="sbt.std.TaskMacro.taskAppend1Impl.init">init</a> = <a href="#sbt.std.TaskMacro.taskMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">taskMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[U])(implicit evidence$1: c.WeakTypeTag[U])c.Expr[sbt.Def.Initialize[sbt.Task[U]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.taskAppend1Impl;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAppend1Impl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.taskAppend1Impl.evidence$23" title="c.WeakTypeTag[U]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.taskAppend1Impl.v" title="c.Expr[U]">v</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.taskAppend1Impl.assign">assign</a> = <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAppend1Impl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.taskAppend1Impl.init" title="c.Expr[sbt.Def.Initialize[sbt.Task[U]]]">init</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.taskAppend1Impl.a" title="c.Expr[sbt.Append.Value[T,U]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;append1&quot;)">Append1InitName</span> <span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.taskAppend1Impl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[sbt.Task[T]]])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[sbt.Task[T]]">Setting</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.taskAppend1Impl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[sbt.Task[T]]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.taskAppend1Impl.assign" title="c.Tree">assign</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="comment">/** Implementation of += macro for settings. */</span>
	<span class="keyword">def</span> <a title="[T, U](c: scala.reflect.macros.Context)(v: c.Expr[U])(a: c.Expr[sbt.Append.Value[T,U]])(implicit evidence$24: c.WeakTypeTag[T], implicit evidence$25: c.WeakTypeTag[U])c.Expr[sbt.Def.Setting[T]]" id="sbt.std.TaskMacro.settingAppend1Impl">settingAppend1Impl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingAppend1Impl;T">T</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.settingAppend1Impl;U">U</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingAppend1Impl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[U]" id="sbt.std.TaskMacro.settingAppend1Impl.v">v</a>: c.<span title="c.Expr[U]">Expr</span><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Value[T,U]]" id="sbt.std.TaskMacro.settingAppend1Impl.a">a</a>: c.<span title="c.Expr[sbt.Append.Value[T,U]]">Expr</span><span class="delimiter">[</span>Append.Value<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[T]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[U]]" id="sbt.std.TaskMacro.settingAppend1Impl.init">init</a> = <a href="SettingMacro.scala.html#sbt.std.SettingMacro" title="sbt.std.SettingMacro.type">SettingMacro</a>.<a href="SettingMacro.scala.html#sbt.std.SettingMacro.settingMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$2: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[T]]">settingMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[U])(implicit evidence$2: c.WeakTypeTag[U])c.Expr[sbt.Def.Initialize[U]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.settingAppend1Impl;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAppend1Impl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.settingAppend1Impl.evidence$25" title="c.WeakTypeTag[U]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.settingAppend1Impl.v" title="c.Expr[U]">v</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.settingAppend1Impl.assign">assign</a> = <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAppend1Impl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.settingAppend1Impl.init" title="c.Expr[sbt.Def.Initialize[U]]">init</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.settingAppend1Impl.a" title="c.Expr[sbt.Append.Value[T,U]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;append1&quot;)">Append1InitName</span> <span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.settingAppend1Impl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[T]])c.Expr[sbt.Def.Setting[T]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.settingAppend1Impl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[T]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.settingAppend1Impl.assign" title="c.Tree">assign</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="comment">/** Implementation of ++= macro for tasks. */</span>
	<span class="keyword">def</span> <a title="[T, U](c: scala.reflect.macros.Context)(vs: c.Expr[U])(a: c.Expr[sbt.Append.Values[T,U]])(implicit evidence$26: c.WeakTypeTag[T], implicit evidence$27: c.WeakTypeTag[U])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" id="sbt.std.TaskMacro.taskAppendNImpl">taskAppendNImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.taskAppendNImpl;T">T</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.taskAppendNImpl;U">U</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.taskAppendNImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[U]" id="sbt.std.TaskMacro.taskAppendNImpl.vs">vs</a>: c.<span title="c.Expr[U]">Expr</span><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Values[T,U]]" id="sbt.std.TaskMacro.taskAppendNImpl.a">a</a>: c.<span title="c.Expr[sbt.Append.Values[T,U]]">Expr</span><span class="delimiter">[</span>Append.Values<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[sbt.Task[U]]]" id="sbt.std.TaskMacro.taskAppendNImpl.init">init</a> = <a href="#sbt.std.TaskMacro.taskMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">taskMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[U])(implicit evidence$1: c.WeakTypeTag[U])c.Expr[sbt.Def.Initialize[sbt.Task[U]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.taskAppendNImpl;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAppendNImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.taskAppendNImpl.evidence$27" title="c.WeakTypeTag[U]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.taskAppendNImpl.vs" title="c.Expr[U]">vs</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.taskAppendNImpl.assign">assign</a> = <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.taskAppendNImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.taskAppendNImpl.init" title="c.Expr[sbt.Def.Initialize[sbt.Task[U]]]">init</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.taskAppendNImpl.a" title="c.Expr[sbt.Append.Values[T,U]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;appendN&quot;)">AppendNInitName</span> <span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.taskAppendNImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[sbt.Task[T]]])c.Expr[sbt.Def.Setting[sbt.Task[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[sbt.Task[T]]">Setting</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.taskAppendNImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[sbt.Task[T]]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.taskAppendNImpl.assign" title="c.Tree">assign</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="comment">/** Implementation of ++= macro for settings. */</span>
	<span class="keyword">def</span> <a title="[T, U](c: scala.reflect.macros.Context)(vs: c.Expr[U])(a: c.Expr[sbt.Append.Values[T,U]])(implicit evidence$28: c.WeakTypeTag[T], implicit evidence$29: c.WeakTypeTag[U])c.Expr[sbt.Def.Setting[T]]" id="sbt.std.TaskMacro.settingAppendNImpl">settingAppendNImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.settingAppendNImpl;T">T</a>: c.WeakTypeTag, <a title="" id="sbt.std.TaskMacro.settingAppendNImpl;U">U</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingAppendNImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[U]" id="sbt.std.TaskMacro.settingAppendNImpl.vs">vs</a>: c.<span title="c.Expr[U]">Expr</span><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Append.Values[T,U]]" id="sbt.std.TaskMacro.settingAppendNImpl.a">a</a>: c.<span title="c.Expr[sbt.Append.Values[T,U]]">Expr</span><span class="delimiter">[</span>Append.Values<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Setting[T]]">Expr</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[U]]" id="sbt.std.TaskMacro.settingAppendNImpl.init">init</a> = <a href="SettingMacro.scala.html#sbt.std.SettingMacro" title="sbt.std.SettingMacro.type">SettingMacro</a>.<a href="SettingMacro.scala.html#sbt.std.SettingMacro.settingMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$2: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[T]]">settingMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[U])(implicit evidence$2: c.WeakTypeTag[U])c.Expr[sbt.Def.Initialize[U]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.settingAppendNImpl;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAppendNImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.settingAppendNImpl.evidence$29" title="c.WeakTypeTag[U]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.settingAppendNImpl.vs" title="c.Expr[U]">vs</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.settingAppendNImpl.assign">assign</a> = <a href="#sbt.std.TaskMacro.appendMacroImpl" title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree">appendMacroImpl</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingAppendNImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.settingAppendNImpl.init" title="c.Expr[sbt.Def.Initialize[U]]">init</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.std.TaskMacro.settingAppendNImpl.a" title="c.Expr[sbt.Append.Values[T,U]]">a</a>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span><span class="delimiter">(</span> <span title="String(&quot;appendN&quot;)">AppendNInitName</span> <span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.settingAppendNImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Setting[T]])c.Expr[sbt.Def.Setting[T]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Setting" title="sbt.Def.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.settingAppendNImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Setting[T]]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.settingAppendNImpl.assign" title="c.Tree">assign</a> <span class="delimiter">)</span>
	<span class="delimiter">}</span>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(c: scala.reflect.macros.Context)(init: c.Tree, append: c.Tree)(newName: String)c.Tree" id="sbt.std.TaskMacro.appendMacroImpl">appendMacroImpl</a><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.appendMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Tree" id="sbt.std.TaskMacro.appendMacroImpl.init">init</a>: c.<span title="c.Tree">Tree</span>, <a title="c.Tree" id="sbt.std.TaskMacro.appendMacroImpl.append">append</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.TaskMacro.appendMacroImpl.newName">newName</a>: <span title="String">String</span><span class="delimiter">)</span>: c.<span title="c.Tree">Tree</span> =
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span class="delimiter">{</span>Apply,ApplyTag,newTermName,Select,SelectTag,TypeApply,TypeApplyTag<span class="delimiter">}</span>
		<a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Tree">macroApplication</span> <span title="c.Tree" class="keyword">match</span> <span class="delimiter">{</span>
			<span class="keyword">case</span> <a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(apply: c.universe.Apply)Option[(c.universe.Tree, List[c.universe.Tree])]">Apply</a><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(x: Any)Option[c.universe.Apply]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(apply: c.universe.Apply)Option[(c.universe.Tree, List[c.universe.Tree])]">Apply</a><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(x: Any)Option[c.universe.Apply]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(typeApply: c.universe.TypeApply)Option[(c.universe.Tree, List[c.universe.Tree])]">TypeApply</a><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(x: Any)Option[c.universe.TypeApply]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(select: c.universe.Select)Option[(c.universe.Tree, c.universe.Name)]">Select</a><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(x: Any)Option[c.universe.Select]" class="delimiter">(</a><a title="c.universe.Tree" id="sbt.std.TaskMacro.appendMacroImpl.preT">preT</a>, <a title="c.universe.Name" id="sbt.std.TaskMacro.appendMacroImpl.nmeT">nmeT</a><span class="delimiter">)</span>, <a title="List[c.universe.Tree]" id="sbt.std.TaskMacro.appendMacroImpl.targs">targs</a><span class="delimiter">)</span>, _<span class="delimiter">)</span>, <a title="List[c.universe.Tree]" id="sbt.std.TaskMacro.appendMacroImpl.a">a</a><span class="delimiter">)</span> =&gt;
				<a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.appendMacroImpl.preT" title="c.universe.Tree">preT</a>, <a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.appendMacroImpl.newName" title="String">newName</a><span class="delimiter">)</span>.<span title="=&gt; c.universe.Name">encodedName</span><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.appendMacroImpl.targs" title="List[c.universe.Tree]">targs</a><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.appendMacroImpl.init" title="c.Tree">init</a> <a href="#sbt.std.TaskMacro.appendMacroImpl.x$2" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <a href="#sbt.std.TaskMacro.sourcePosition" title="(c: scala.reflect.macros.Context)c.Expr[sbt.SourcePosition]">sourcePosition</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.appendMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span> <a href="#sbt.std.TaskMacro.appendMacroImpl.x$1" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.appendMacroImpl.a" title="List[c.universe.Tree]">a</a><span class="delimiter">)</span>
			<span class="keyword">case</span> <a title="c.Tree" id="sbt.std.TaskMacro.appendMacroImpl.x">x</a> =&gt; <a href="../appmacro/ContextUtil.scala.html#sbt.appmacro.ContextUtil" title="sbt.appmacro.ContextUtil.type">ContextUtil</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro.ContextUtil.unexpectedTree" title="(tree: _449.universe.Tree forSome { val _449: scala.reflect.macros.Context })Nothing">unexpectedTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.appendMacroImpl.x" title="c.Tree">x</a><span class="delimiter">)</span>
		<span class="delimiter">}</span>
	<span class="delimiter">}</span>
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(c: scala.reflect.macros.Context)(init: c.Tree)(newName: String)c.Tree" id="sbt.std.TaskMacro.transformMacroImpl">transformMacroImpl</a><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.transformMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Tree" id="sbt.std.TaskMacro.transformMacroImpl.init">init</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.TaskMacro.transformMacroImpl.newName">newName</a>: <span title="String">String</span><span class="delimiter">)</span>: c.<span title="c.Tree">Tree</span> =
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span class="delimiter">{</span>Apply,ApplyTag,newTermName,Select,SelectTag<span class="delimiter">}</span>
		<span class="keyword">val</span> <a title="c.universe.Tree" id="sbt.std.TaskMacro.transformMacroImpl.target">target</a> = 
			<a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Tree">macroApplication</span> <span title="c.universe.Tree" class="keyword">match</span> <span class="delimiter">{</span>
				<span class="keyword">case</span> <a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="(apply: c.universe.Apply)Option[(c.universe.Tree, List[c.universe.Tree])]">Apply</a><a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="(x: Any)Option[c.universe.Apply]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="(select: c.universe.Select)Option[(c.universe.Tree, c.universe.Name)]">Select</a><a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="(x: Any)Option[c.universe.Select]" class="delimiter">(</a><a title="c.universe.Tree" id="sbt.std.TaskMacro.transformMacroImpl.target.prefix">prefix</a>, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#sbt.std.TaskMacro.transformMacroImpl.target.prefix" title="c.universe.Tree">prefix</a>
				<span class="keyword">case</span> <a title="c.Tree" id="sbt.std.TaskMacro.transformMacroImpl.target.x">x</a> =&gt; <a href="../appmacro/ContextUtil.scala.html#sbt.appmacro.ContextUtil" title="sbt.appmacro.ContextUtil.type">ContextUtil</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro.ContextUtil.unexpectedTree" title="(tree: _449.universe.Tree forSome { val _449: scala.reflect.macros.Context })Nothing">unexpectedTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.transformMacroImpl.target.x" title="c.Tree">x</a><span class="delimiter">)</span>
			<span class="delimiter">}</span>
		<a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="=&gt; c.universe.ApplyExtractor">Apply</a>.<span title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">apply</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.transformMacroImpl.target" title="c.universe.Tree">target</a>, <a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.transformMacroImpl.newName" title="String">newName</a><span class="delimiter">)</span>.<span title="=&gt; c.universe.Name">encodedName</span><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.transformMacroImpl.init" title="c.Tree">init</a> <a href="#sbt.std.TaskMacro.transformMacroImpl.x$4" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <a href="#sbt.std.TaskMacro.sourcePosition" title="(c: scala.reflect.macros.Context)c.Expr[sbt.SourcePosition]">sourcePosition</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.transformMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span> <a href="#sbt.std.TaskMacro.transformMacroImpl.x$3" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(c: scala.reflect.macros.Context)c.Expr[sbt.SourcePosition]" id="sbt.std.TaskMacro.sourcePosition">sourcePosition</a><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.sourcePosition.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.SourcePosition]">Expr</span><span class="delimiter">[</span>SourcePosition<span class="delimiter">]</span> =
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="#sbt.std.TaskMacro.sourcePosition.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
		<span class="keyword">val</span> <a title="c.Position" id="sbt.std.TaskMacro.sourcePosition.pos">pos</a> = <a href="#sbt.std.TaskMacro.sourcePosition.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>
		<span title="c.Expr[sbt.SourcePosition]" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.sourcePosition.pos" title="c.Position">pos</a>.<span title="=&gt; Boolean">isDefined</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.std.TaskMacro.sourcePosition.pos" title="c.Position">pos</a>.<span title="=&gt; Int">line</span> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.std.TaskMacro.sourcePosition.pos" title="c.Position">pos</a>.<span title="=&gt; scala.reflect.internal.util.SourceFile">source</span> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="scala.reflect.io.AbstractFile" id="sbt.std.TaskMacro.sourcePosition.f">f</a> = <a href="#sbt.std.TaskMacro.sourcePosition.pos" title="c.Position">pos</a>.<span title="=&gt; scala.reflect.internal.util.SourceFile">source</span>.<span title="=&gt; scala.reflect.io.AbstractFile">file</span>
			<span class="keyword">val</span> <a title="c.Expr[String]" id="sbt.std.TaskMacro.sourcePosition.name">name</a> = <a href="#sbt.std.TaskMacro.constant" title="[T](c: scala.reflect.macros.Context, t: T)(implicit evidence$30: c.TypeTag[T])c.Expr[T]">constant</a><span title="(c: scala.reflect.macros.Context, t: String)(implicit evidence$30: c.TypeTag[String])c.Expr[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.sourcePosition.c" title="(u: scala.reflect.api.Universe)u.TypeTag[String]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.sourcePosition.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.TaskMacro.settingSource" title="(c: scala.reflect.macros.Context, path: String, name: String)String">settingSource</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.sourcePosition.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.TaskMacro.sourcePosition.f" title="scala.reflect.io.AbstractFile">f</a>.<span title="=&gt; String">path</span>, <a href="#sbt.std.TaskMacro.sourcePosition.f" title="scala.reflect.io.AbstractFile">f</a>.<span title="=&gt; String">name</span><span class="delimiter">)</span><span class="delimiter">)</span>
			<span class="keyword">val</span> <a title="c.Expr[Int]" id="sbt.std.TaskMacro.sourcePosition.line">line</a> = <a href="#sbt.std.TaskMacro.constant" title="[T](c: scala.reflect.macros.Context, t: T)(implicit evidence$30: c.TypeTag[T])c.Expr[T]">constant</a><span title="(c: scala.reflect.macros.Context, t: Int)(implicit evidence$30: c.TypeTag[Int])c.Expr[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.sourcePosition.c" title="(u: scala.reflect.api.Universe)u.TypeTag[Int]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.sourcePosition.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.TaskMacro.sourcePosition.pos" title="c.Position">pos</a>.<span title="=&gt; Int">line</span><span class="delimiter">)</span>
			<a href="#sbt.std.TaskMacro.sourcePosition.c" title="(expr: sbt.LinePosition)c.universe.Expr[sbt.LinePosition]">reify</a> <span class="delimiter">{</span> sbt.<a href="../Positions.scala.html#sbt;LinePosition" title="(path: String, startLine: Int)sbt.LinePosition">LinePosition</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.sourcePosition.name" title="c.Expr[String]">name</a>.<span title="=&gt; String">splice</span>, <a href="#sbt.std.TaskMacro.sourcePosition.line" title="c.Expr[Int]">line</a>.<span title="=&gt; Int">splice</span><span class="delimiter">)</span> <span class="delimiter">}</span>
		<span class="delimiter">}</span>
		<span class="keyword">else</span>
			<a href="#sbt.std.TaskMacro.sourcePosition.c" title="(expr: sbt.NoPosition.type)c.universe.Expr[sbt.NoPosition.type]">reify</a><span class="delimiter">{</span> sbt.<a href="../Positions.scala.html#sbt.NoPosition" title="sbt.NoPosition.type">NoPosition</a> <span class="delimiter">}</span>
	<span class="delimiter">}</span>
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(c: scala.reflect.macros.Context, path: String, name: String)String" id="sbt.std.TaskMacro.settingSource">settingSource</a><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.settingSource.c">c</a>: <span title="scala.reflect.macros.Context">Context</span>, <a title="String" id="sbt.std.TaskMacro.settingSource.path">path</a>: <span title="String">String</span>, <a title="String" id="sbt.std.TaskMacro.settingSource.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="c.universe.Symbol" id="sbt.std.TaskMacro.settingSource.ec">ec</a> = <a href="#sbt.std.TaskMacro.settingSource.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Tree">enclosingClass</span>.<span title="=&gt; c.universe.Symbol">symbol</span>
		<span class="keyword">def</span> <a title="(s: c.Symbol)Boolean" id="sbt.std.TaskMacro.settingSource.inEmptyPackage">inEmptyPackage</a><span class="delimiter">(</span><a title="c.Symbol" id="sbt.std.TaskMacro.settingSource.inEmptyPackage.s">s</a>: c.<span title="c.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
			<a href="#sbt.std.TaskMacro.settingSource.inEmptyPackage.s" title="c.Symbol">s</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.std.TaskMacro.settingSource.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="=&gt; c.universe.Symbol">NoSymbol</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingSource.inEmptyPackage.s" title="c.Symbol">s</a>.<span title="=&gt; c.universe.Symbol">owner</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.std.TaskMacro.settingSource.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.universe.Mirror">mirror</span>.<span title="=&gt; c.universe.ModuleSymbol">EmptyPackage</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.std.TaskMacro.settingSource.inEmptyPackage.s" title="c.Symbol">s</a>.<span title="=&gt; c.universe.Symbol">owner</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.std.TaskMacro.settingSource.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.universe.Mirror">mirror</span>.<span title="=&gt; c.universe.ClassSymbol">EmptyPackageClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.std.TaskMacro.settingSource.inEmptyPackage" title="(s: c.Symbol)Boolean">inEmptyPackage</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingSource.inEmptyPackage.s" title="c.Symbol">s</a>.<span title="=&gt; c.universe.Symbol">owner</span><span class="delimiter">)</span><span class="delimiter">)</span>
		<span title="String" class="keyword">if</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.std.TaskMacro.settingSource.ec" title="c.universe.Symbol">ec</a>.<span title="=&gt; Boolean">isStatic</span><span class="delimiter">)</span>
			<a href="#sbt.std.TaskMacro.settingSource.name" title="String">name</a>
		<span class="keyword">else</span> <span title="String" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingSource.inEmptyPackage" title="(s: c.Symbol)Boolean">inEmptyPackage</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.settingSource.ec" title="c.universe.Symbol">ec</a><span class="delimiter">)</span><span class="delimiter">)</span>
			<a href="#sbt.std.TaskMacro.settingSource.path" title="String">path</a>
		<span class="keyword">else</span>
			<span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;(&quot;)">($</span><span class="delimiter">{</span><a href="#sbt.std.TaskMacro.settingSource.ec" title="c.universe.Symbol">ec</a>.<span title="=&gt; String">fullName</span><span class="delimiter">}</span><span title="String(&quot;) &quot;)">) $</span><a href="#sbt.std.TaskMacro.settingSource.name" title="String">name</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
	<span class="delimiter">}</span>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context, t: T)(implicit evidence$30: c.TypeTag[T])c.Expr[T]" id="sbt.std.TaskMacro.constant">constant</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.constant;T">T</a>: c.TypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.constant.c">c</a>: <span title="scala.reflect.macros.Context">Context</span>, <a title="T" id="sbt.std.TaskMacro.constant.t">t</a>: <a href="#sbt.std.TaskMacro.constant;T" title="T">T</a><span class="delimiter">)</span>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
		<span class="keyword">import</span> <a href="#sbt.std.TaskMacro.constant.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
		<a href="#sbt.std.TaskMacro.constant.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.constant;T" title="T">T</a><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.constant.evidence$30" title="c.TypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.constant.c" title="(value: c.universe.Constant)c.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.constant.c" title="(value: Any)c.universe.Constant">Constant</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.constant.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>


	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$31: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskMacroImpl">inputTaskMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.inputTaskMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.inputTaskMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.inputTaskMacroImpl.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.inputTaskMacro0" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$33: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">inputTaskMacro0</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$33: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskMacroImpl;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.inputTaskMacroImpl.evidence$31" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskMacroImpl.t" title="c.Expr[T]">t</a><span class="delimiter">)</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$32: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskDynMacroImpl">inputTaskDynMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.inputTaskDynMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.inputTaskDynMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.inputTaskDynMacroImpl.t">t</a>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.inputTaskDynMacro0" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$39: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">inputTaskDynMacro0</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$39: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskDynMacroImpl;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacroImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.inputTaskDynMacroImpl.evidence$32" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskDynMacroImpl.t" title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">t</a><span class="delimiter">)</span>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$33: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskMacro0">inputTaskMacro0</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.inputTaskMacro0;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.inputTaskMacro0.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.inputTaskMacro0.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="#sbt.std.TaskMacro.iInitializeMacro" title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(f: c.Expr[T] =&gt; c.Expr[sbt.InputTask[T]])(implicit tt: c.WeakTypeTag[T], implicit mt: c.WeakTypeTag[sbt.InputTask[T]])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">iInitializeMacro</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskMacro0.t" title="c.Expr[T]">t</a><span class="delimiter">)</span> <a href="#sbt.std.TaskMacro.inputTaskMacro0.evidence$33" title="c.WeakTypeTag[T]" class="delimiter">{</a> <a title="c.Expr[T]" id="sbt.std.TaskMacro.inputTaskMacro0.$anonfun.et">et</a> =&gt;
			<span class="keyword">val</span> <a title="c.Expr[sbt.State =&gt; sbt.complete.Parser[sbt.Task[T]]]" id="sbt.std.TaskMacro.inputTaskMacro0.$anonfun.pt">pt</a> = <a href="#sbt.std.TaskMacro.iParserMacro" title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(f: c.Expr[T] =&gt; c.Expr[sbt.Task[T]])(implicit tt: c.WeakTypeTag[T], implicit mt: c.WeakTypeTag[sbt.Task[T]])c.Expr[sbt.State =&gt; sbt.complete.Parser[sbt.Task[T]]]">iParserMacro</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskMacro0.$anonfun.et" title="c.Expr[T]">et</a><span class="delimiter">)</span> <a href="#sbt.std.TaskMacro.inputTaskMacro0.evidence$33" title="c.WeakTypeTag[T]" class="delimiter">{</a> <a title="c.Expr[T]" id="sbt.std.TaskMacro.inputTaskMacro0.$anonfun.pt.$anonfun.pt">pt</a> =&gt; 
				<a href="#sbt.std.TaskMacro.iTaskMacro" title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$38: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]">iTaskMacro</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.inputTaskMacro0.evidence$33" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskMacro0.$anonfun.pt.$anonfun.pt" title="c.Expr[T]">pt</a><span class="delimiter">)</span>
			<span class="delimiter">}</span>
			<a href="#sbt.std.TaskMacro.inputTaskMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.InputTask[T])c.universe.Expr[sbt.InputTask[T]]">reify</span> <span class="delimiter">{</span> <a href="../InputTask.scala.html#sbt.InputTask" title="sbt.InputTask.type">InputTask</a>.<a href="../InputTask.scala.html#sbt.InputTask.make" title="(p: sbt.State =&gt; sbt.complete.Parser[sbt.Task[T]])sbt.InputTask[T]">make</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskMacro0.$anonfun.pt" title="c.Expr[sbt.State =&gt; sbt.complete.Parser[sbt.Task[T]]]">pt</a>.<span title="=&gt; sbt.State =&gt; sbt.complete.Parser[sbt.Task[T]]">splice</span><span class="delimiter">)</span> <span class="delimiter">}</span>
		<span class="delimiter">}</span>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[M[_], T](c: scala.reflect.macros.Context)(t: c.Expr[T])(f: c.Expr[T] =&gt; c.Expr[M[T]])(implicit tt: c.WeakTypeTag[T], implicit mt: c.WeakTypeTag[M[T]])c.Expr[sbt.Def.Initialize[M[T]]]" id="sbt.std.TaskMacro.iInitializeMacro">iInitializeMacro</a><span class="delimiter">[</span><a title="[_]" id="sbt.std.TaskMacro.iInitializeMacro;M">M</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.iInitializeMacro;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.std.TaskMacro.iInitializeMacro;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.iInitializeMacro.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.iInitializeMacro.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T] =&gt; c.Expr[M[T]]" id="sbt.std.TaskMacro.iInitializeMacro.f">f</a>: c.Expr<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; c.Expr<span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="c.WeakTypeTag[T]" id="sbt.std.TaskMacro.iInitializeMacro.tt">tt</a>: c.<span title="c.WeakTypeTag[T]">WeakTypeTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="c.WeakTypeTag[M[T]]" id="sbt.std.TaskMacro.iInitializeMacro.mt">mt</a>: c.<span title="c.WeakTypeTag[M[T]]">WeakTypeTag</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[M[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="sbt.appmacro.Instance.Transform[c.type,M]" id="sbt.std.TaskMacro.iInitializeMacro.inner">inner</a>: <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance;Transform" title="sbt.appmacro.Instance.Transform[c.type,M]">Transform</a><span class="delimiter">[</span>c.<span class="keyword">type</span>,M<span class="delimiter">]</span> = <a href="#sbt.std.TaskMacro.iInitializeMacro.inner;$anon" title="sbt.appmacro.Instance.Transform[c.type,M]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.appmacro.Instance.Transform[c.type,M]" id="sbt.std.TaskMacro.iInitializeMacro.inner;$anon">Transform</a><span class="delimiter">[</span>c.<span class="keyword">type</span>,M<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="(in: c.Tree)c.Tree" id="sbt.std.TaskMacro.iInitializeMacro.inner;$anon.apply">apply</a><span class="delimiter">(</span><a title="c.Tree" id="sbt.std.TaskMacro.iInitializeMacro.inner;$anon.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: c.<span title="c.Tree">Tree</span> = <a href="#sbt.std.TaskMacro.iInitializeMacro.f" title="(v1: c.Expr[T])c.Expr[M[T]]">f</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iInitializeMacro.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.iInitializeMacro;T" title="T">T</a><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.iInitializeMacro.tt" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.iInitializeMacro.inner;$anon.apply.in" title="c.Tree">in</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">}</span>
		<span class="keyword">val</span> <a title="c.Expr[T]" id="sbt.std.TaskMacro.iInitializeMacro.cond">cond</a> = <a href="#sbt.std.TaskMacro.iInitializeMacro.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.iInitializeMacro;T" title="T">T</a><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.iInitializeMacro.tt" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree" title="(c: scala.reflect.macros.Context)(t: c.Tree)c.Tree">conditionInputTaskTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iInitializeMacro.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iInitializeMacro.t" title="c.Expr[T]">t</a>.<span title="=&gt; c.universe.Tree">tree</span><span class="delimiter">)</span><span class="delimiter">)</span>
		<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,M])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[M[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[M[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.iInitializeMacro;T" title="T">T</a>,<a href="#sbt.std.TaskMacro.iInitializeMacro;M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iInitializeMacro.c" title="scala.reflect.macros.Context">c</a>, <a href="SettingMacro.scala.html#sbt.std.InitializeInstance" title="sbt.std.InitializeInstance.type">InitializeInstance</a>, <a href="InputConvert.scala.html#sbt.std.InputInitConvert" title="sbt.std.InputInitConvert.type">InputInitConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.iInitializeMacro.tt" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(a: c.Expr[T])scala.util.Left[c.Expr[T],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iInitializeMacro.cond" title="c.Expr[T]">cond</a><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.iInitializeMacro.inner" title="sbt.appmacro.Instance.Transform[c.type,M]">inner</a><span class="delimiter">)</span>
	<span class="delimiter">}</span>
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(c: scala.reflect.macros.Context)(t: c.Tree)c.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree">conditionInputTaskTree</a><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.conditionInputTaskTree.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.t">t</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: c.<span title="c.Tree">Tree</span> =
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
			<span class="keyword">import</span> <a href="InputWrapper.scala.html#sbt.std.InputWrapper" title="sbt.std.InputWrapper.type">InputWrapper</a>._
		<span class="keyword">def</span> <a title="[T](tree: c.universe.Tree)(implicit evidence$34: c.WeakTypeTag[T])c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask">wrapInitTask</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask.tree">tree</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> =
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask.e">e</a> = <a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[sbt.Task[T]]])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.Task[T]]">Initialize</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[sbt.Task[T]]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span>
			<a href="InputWrapper.scala.html#sbt.std.InputWrapper.wrapTask" title="[T](c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">wrapTask</a><span title="(c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask.evidence$34" title="c.WeakTypeTag[T]" class="delimiter">(</a> <a href="InputWrapper.scala.html#sbt.std.InputWrapper.wrapInit" title="[T](c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$2: c.WeakTypeTag[T])c.Expr[T]">wrapInit</a><span title="(c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$2: c.WeakTypeTag[sbt.Task[T]])c.Expr[sbt.Task[T]]" class="delimiter">[</span><a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Task[T]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask.e" title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">e</a>, <a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span>
		<span class="delimiter">}</span>
		<span class="keyword">def</span> <a title="[T](tree: c.universe.Tree)(implicit evidence$35: c.WeakTypeTag[T])c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser">wrapInitParser</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser.tree">tree</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> =
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]]" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser.e">e</a> = <a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]])c.Expr[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]">Initialize</a><span class="delimiter">[</span>State =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span>
			<a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.wrap" title="[T](c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$8: c.WeakTypeTag[T])c.Expr[T]">wrap</a><span title="(c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$8: c.WeakTypeTag[T])c.Expr[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser.evidence$35" title="c.WeakTypeTag[T]" class="delimiter">(</a> <a href="InputWrapper.scala.html#sbt.std.InputWrapper.wrapInit" title="[T](c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$2: c.WeakTypeTag[T])c.Expr[T]">wrapInit</a><span title="(c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$2: c.WeakTypeTag[sbt.State =&gt; sbt.complete.Parser[T]])c.Expr[sbt.State =&gt; sbt.complete.Parser[T]]" class="delimiter">[</span>State =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.State =&gt; sbt.complete.Parser[T]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser.e" title="c.Expr[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]]">e</a>, <a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span>
		<span class="delimiter">}</span>
		<span class="keyword">def</span> <a title="[T](tree: c.universe.Tree)(implicit evidence$36: c.WeakTypeTag[T])c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput">wrapInitInput</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput.tree">tree</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> =
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput.e">e</a> = <a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[sbt.InputTask[T]]])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.InputTask[T]]">Initialize</a><span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span>
			<a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput" title="[T](tree: c.universe.Tree)(implicit evidence$37: c.WeakTypeTag[T])c.universe.Tree">wrapInput</a><span title="(tree: c.universe.Tree)(implicit evidence$37: c.WeakTypeTag[T])c.universe.Tree" class="delimiter">[</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput;T" title="T">T</a><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput.evidence$36" title="c.WeakTypeTag[T]" class="delimiter">(</a> <a href="InputWrapper.scala.html#sbt.std.InputWrapper.wrapInit" title="[T](c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$2: c.WeakTypeTag[T])c.Expr[T]">wrapInit</a><span title="(c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$2: c.WeakTypeTag[sbt.InputTask[T]])c.Expr[sbt.InputTask[T]]" class="delimiter">[</span><a href="../InputTask.scala.html#sbt;InputTask" title="sbt.InputTask[T]">InputTask</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.InputTask[T]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput.e" title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">e</a>, <a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span>
		<span class="delimiter">}</span>
		<span class="keyword">def</span> <a title="[T](tree: c.universe.Tree)(implicit evidence$37: c.WeakTypeTag[T])c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInput">wrapInput</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInput;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.tree">tree</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> =
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="c.Expr[sbt.InputTask[T]]" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.e">e</a> = <a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.InputTask[T]])c.Expr[sbt.InputTask[T]]" class="delimiter">[</span><a href="../InputTask.scala.html#sbt;InputTask" title="sbt.InputTask[T]">InputTask</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.InputTask[T]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span>
			<span class="keyword">val</span> <a title="c.Expr[sbt.Task[T]]" id="sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.p">p</a> = <a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.wrap" title="[T](c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$8: c.WeakTypeTag[T])c.Expr[T]">wrap</a><span title="(c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$8: c.WeakTypeTag[sbt.Task[T]])c.Expr[sbt.Task[T]]" class="delimiter">[</span><a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Task[T]]" class="delimiter">(</a> <a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.inputParser" title="(c: scala.reflect.macros.Context)(t: c.Expr[sbt.InputTask[T]])(implicit evidence$10: c.WeakTypeTag[T])c.Expr[sbt.State =&gt; sbt.complete.Parser[sbt.Task[T]]]">inputParser</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.evidence$37" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.e" title="c.Expr[sbt.InputTask[T]]">e</a><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span> <span class="delimiter">)</span>
			<a href="InputWrapper.scala.html#sbt.std.InputWrapper.wrapTask" title="[T](c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">wrapTask</a><span title="(c: scala.reflect.macros.Context)(ts: c.Expr[Any], pos: c.Position)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.evidence$37" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.p" title="c.Expr[sbt.Task[T]]">p</a>, <a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span>
		<span class="delimiter">}</span>

		<span class="keyword">def</span> <a title="(nme: String, tpe: c.universe.Type, tree: c.universe.Tree)sbt.appmacro.Converted[c.type]" id="sbt.std.TaskMacro.conditionInputTaskTree.expand">expand</a><span class="delimiter">(</span><a title="String" id="sbt.std.TaskMacro.conditionInputTaskTree.expand.nme">nme</a>: <span title="String">String</span>, <a title="c.universe.Type" id="sbt.std.TaskMacro.conditionInputTaskTree.expand.tpe">tpe</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.expand.tree">tree</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> = <a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.nme" title="String">nme</a> <span title="sbt.appmacro.Converted[c.type]" class="keyword">match</span> <span class="delimiter">{</span>
			<span class="keyword">case</span> <span title="String(&quot;wrapInitTask_&quot;)">WrapInitTaskName</span> =&gt; <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitTask" title="(tree: c.universe.Tree)(implicit evidence$34: c.WeakTypeTag[Nothing])c.universe.Tree">wrapInitTask</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="(tpe: c.Type)c.WeakTypeTag[Nothing]">WeakTypeTag</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
			<span class="keyword">case</span> <a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.WrapInitName" title="=&gt; String">WrapInitName</a> =&gt; <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitParser" title="(tree: c.universe.Tree)(implicit evidence$35: c.WeakTypeTag[Nothing])c.universe.Tree">wrapInitParser</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="(tpe: c.Type)c.WeakTypeTag[Nothing]">WeakTypeTag</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
			<span class="keyword">case</span> <span title="String(&quot;wrapInitInputTask_&quot;)">WrapInitInputName</span> =&gt; <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInitInput" title="(tree: c.universe.Tree)(implicit evidence$36: c.WeakTypeTag[Nothing])c.universe.Tree">wrapInitInput</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="(tpe: c.Type)c.WeakTypeTag[Nothing]">WeakTypeTag</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
			<span class="keyword">case</span> <span title="String(&quot;wrapInputTask_&quot;)">WrapInputName</span> =&gt; <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.wrapInput" title="(tree: c.universe.Tree)(implicit evidence$37: c.WeakTypeTag[Nothing])c.universe.Tree">wrapInput</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a>.<span title="(tpe: c.Type)c.WeakTypeTag[Nothing]">WeakTypeTag</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
			<span class="keyword">case</span> _ =&gt; <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.NotApplicable" title="sbt.appmacro.Converted.NotApplicable[c.type]">NotApplicable</a>
		<span class="delimiter">}</span>
		<span class="keyword">val</span> <a title="sbt.appmacro.ContextUtil[c.type]" id="sbt.std.TaskMacro.conditionInputTaskTree.util">util</a> = <a href="../appmacro/ContextUtil.scala.html#sbt.appmacro.ContextUtil.apply" title="[C &lt;: scala.reflect.macros.Context with Singleton](c: C)sbt.appmacro.ContextUtil[C]">ContextUtil</a><span title="(c: c.type)sbt.appmacro.ContextUtil[c.type]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.conditionInputTaskTree.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.transformWrappers" title="(t: util.ctx.universe.Tree, subWrapper: (String, util.ctx.universe.Type, util.ctx.universe.Tree) =&gt; sbt.appmacro.Converted[util.ctx.type])util.ctx.universe.Tree">transformWrappers</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.t" title="c.Tree">t</a>, <span class="delimiter">(</span><a title="String" id="sbt.std.TaskMacro.conditionInputTaskTree.$anonfun.nme">nme</a>,<a title="util.ctx.universe.Type" id="sbt.std.TaskMacro.conditionInputTaskTree.$anonfun.tpe">tpe</a>,<a title="util.ctx.universe.Tree" id="sbt.std.TaskMacro.conditionInputTaskTree.$anonfun.tree">tree</a><span class="delimiter">)</span> =&gt; <a href="#sbt.std.TaskMacro.conditionInputTaskTree.expand" title="(nme: String, tpe: c.universe.Type, tree: c.universe.Tree)sbt.appmacro.Converted[c.type]">expand</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.conditionInputTaskTree.$anonfun.nme" title="String">nme</a>,<a href="#sbt.std.TaskMacro.conditionInputTaskTree.$anonfun.tpe" title="util.ctx.universe.Type">tpe</a>,<a href="#sbt.std.TaskMacro.conditionInputTaskTree.$anonfun.tree" title="util.ctx.universe.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>
		
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[M[_], T](c: scala.reflect.macros.Context)(t: c.Expr[T])(f: c.Expr[T] =&gt; c.Expr[M[T]])(implicit tt: c.WeakTypeTag[T], implicit mt: c.WeakTypeTag[M[T]])c.Expr[sbt.State =&gt; sbt.complete.Parser[M[T]]]" id="sbt.std.TaskMacro.iParserMacro">iParserMacro</a><span class="delimiter">[</span><a title="[_]" id="sbt.std.TaskMacro.iParserMacro;M">M</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.iParserMacro;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.std.TaskMacro.iParserMacro;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.iParserMacro.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.iParserMacro.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T] =&gt; c.Expr[M[T]]" id="sbt.std.TaskMacro.iParserMacro.f">f</a>: c.Expr<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; c.Expr<span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="c.WeakTypeTag[T]" id="sbt.std.TaskMacro.iParserMacro.tt">tt</a>: c.<span title="c.WeakTypeTag[T]">WeakTypeTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="c.WeakTypeTag[M[T]]" id="sbt.std.TaskMacro.iParserMacro.mt">mt</a>: c.<span title="c.WeakTypeTag[M[T]]">WeakTypeTag</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.State =&gt; sbt.complete.Parser[M[T]]]">Expr</span><span class="delimiter">[</span>State =&gt; Parser<span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="sbt.appmacro.Instance.Transform[c.type,M]" id="sbt.std.TaskMacro.iParserMacro.inner">inner</a>: <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance;Transform" title="sbt.appmacro.Instance.Transform[c.type,M]">Transform</a><span class="delimiter">[</span>c.<span class="keyword">type</span>,M<span class="delimiter">]</span> = <a href="#sbt.std.TaskMacro.iParserMacro.inner;$anon" title="sbt.appmacro.Instance.Transform[c.type,M]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.appmacro.Instance.Transform[c.type,M]" id="sbt.std.TaskMacro.iParserMacro.inner;$anon">Transform</a><span class="delimiter">[</span>c.<span class="keyword">type</span>,M<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="(in: c.Tree)c.Tree" id="sbt.std.TaskMacro.iParserMacro.inner;$anon.apply">apply</a><span class="delimiter">(</span><a title="c.Tree" id="sbt.std.TaskMacro.iParserMacro.inner;$anon.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: c.<span title="c.Tree">Tree</span> = <a href="#sbt.std.TaskMacro.iParserMacro.f" title="(v1: c.Expr[T])c.Expr[M[T]]">f</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iParserMacro.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.iParserMacro;T" title="T">T</a><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.iParserMacro.tt" title="c.WeakTypeTag[T]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.iParserMacro.inner;$anon.apply.in" title="c.Tree">in</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">}</span>
		<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,M])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[M[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[M[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.iParserMacro;T" title="T">T</a>,<a href="#sbt.std.TaskMacro.iParserMacro;M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iParserMacro.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.ParserInstance" title="sbt.std.ParserInstance.type">ParserInstance</a>, <a href="InputConvert.scala.html#sbt.std.ParserConvert" title="sbt.std.ParserConvert.type">ParserConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.iParserMacro.tt" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(a: c.Expr[T])scala.util.Left[c.Expr[T],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iParserMacro.t" title="c.Expr[T]">t</a><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.iParserMacro.inner" title="sbt.appmacro.Instance.Transform[c.type,M]">inner</a><span class="delimiter">)</span>
	<span class="delimiter">}</span>
		
	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$38: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]" id="sbt.std.TaskMacro.iTaskMacro">iTaskMacro</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.iTaskMacro;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.iTaskMacro.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.TaskMacro.iTaskMacro.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Task[T]]">Expr</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
		<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[sbt.Types.Id[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[sbt.Types.Id[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.iTaskMacro;T" title="T">T</a>,<a href="../TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iTaskMacro.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.TaskInstance" title="sbt.std.TaskInstance.type">TaskInstance</a>, <a href="InputConvert.scala.html#sbt.std.TaskConvert" title="sbt.std.TaskConvert.type">TaskConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.iTaskMacro.evidence$38" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(a: c.Expr[T])scala.util.Left[c.Expr[T],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.iTaskMacro.t" title="c.Expr[T]">t</a><span class="delimiter">)</span>, <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.idTransform" title="sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id]">idTransform</a><span class="delimiter">)</span>

	<span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$39: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskDynMacro0">inputTaskDynMacro0</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.inputTaskDynMacro0;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskMacro.inputTaskDynMacro0.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" id="sbt.std.TaskMacro.inputTaskDynMacro0.t">t</a>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =	
	<span class="delimiter">{</span>
			<span class="keyword">import</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span class="delimiter">{</span>Apply=&gt;ApplyTree,_<span class="delimiter">}</span>
		
		<span class="keyword">val</span> <a title="c.WeakTypeTag[T]" id="sbt.std.TaskMacro.inputTaskDynMacro0.tag">tag</a> = <span title="[T](implicit e: T)T">implicitly</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.evidence$39" title="(implicit e: c.WeakTypeTag[T])c.WeakTypeTag[T]" class="delimiter">[</a>c.<span title="c.WeakTypeTag[T]">WeakTypeTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
		<span class="keyword">val</span> <a title="sbt.appmacro.ContextUtil[c.type]" id="sbt.std.TaskMacro.inputTaskDynMacro0.util">util</a> = <a href="../appmacro/ContextUtil.scala.html#sbt.appmacro.ContextUtil.apply" title="[C &lt;: scala.reflect.macros.Context with Singleton](c: C)sbt.appmacro.ContextUtil[C]">ContextUtil</a><span title="(c: c.type)sbt.appmacro.ContextUtil[c.type]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.universe.Ident" id="sbt.std.TaskMacro.inputTaskDynMacro0.it">it</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.singleton" title="(i: sbt.InputTask.type)(implicit it: util.ctx.TypeTag[i.type])util.ctx.universe.Symbol">singleton</a><a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.ctx" title="(u: scala.reflect.api.Universe)u.TypeTag[sbt.InputTask.type]" class="delimiter">(</a><a href="../InputTask.scala.html#sbt.InputTask" title="sbt.InputTask.type">InputTask</a><span class="delimiter">)</span><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="(String, c.Type, c.Tree) =&gt; Boolean" id="sbt.std.TaskMacro.inputTaskDynMacro0.isParserWrapper">isParserWrapper</a> = <a href="InputConvert.scala.html#sbt.std.InitParserConvert" title="sbt.std.InitParserConvert.type">InitParserConvert</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert.asPredicate" title="(c: scala.reflect.macros.Context)(String, c.Type, c.Tree) =&gt; Boolean">asPredicate</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="(String, c.Type, c.Tree) =&gt; Boolean" id="sbt.std.TaskMacro.inputTaskDynMacro0.isTaskWrapper">isTaskWrapper</a> = <a href="InputConvert.scala.html#sbt.std.FullConvert" title="sbt.std.FullConvert.type">FullConvert</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert.asPredicate" title="(c: scala.reflect.macros.Context)(String, c.Type, c.Tree) =&gt; Boolean">asPredicate</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="(String, c.universe.Type, c.universe.Tree) =&gt; Boolean" id="sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper">isAnyWrapper</a> = <span class="delimiter">(</span>n: <span title="String">String</span>, tpe: <span title="c.universe.Type">Type</span>, tr: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> =&gt; <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isParserWrapper" title="(v1: String, v2: c.Type, v3: c.Tree)Boolean">isParserWrapper</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper.$anonfun.n" title="String">n</a>,<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper.$anonfun.tpe" title="c.universe.Type">tpe</a>,<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper.$anonfun.tr" title="c.universe.Tree">tr</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isTaskWrapper" title="(v1: String, v2: c.Type, v3: c.Tree)Boolean">isTaskWrapper</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper.$anonfun.n" title="String">n</a>,<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper.$anonfun.tpe" title="c.universe.Type">tpe</a>,<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper.$anonfun.tr" title="c.universe.Tree">tr</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.ttree">ttree</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.t" title="c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">t</a>.<span title="=&gt; c.universe.Tree">tree</span>
		<span class="keyword">val</span> <a title="scala.collection.Set[util.ctx.universe.Symbol]" id="sbt.std.TaskMacro.inputTaskDynMacro0.defs">defs</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.collectDefs" title="(tree: util.ctx.universe.Tree, isWrapper: (String, util.ctx.universe.Type, util.ctx.universe.Tree) =&gt; Boolean)scala.collection.Set[util.ctx.universe.Symbol]">collectDefs</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.ttree" title="c.universe.Tree">ttree</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper" title="(String, c.universe.Type, c.universe.Tree) =&gt; Boolean">isAnyWrapper</a><span class="delimiter">)</span>
		<span class="keyword">val</span> <a title="util.ctx.universe.Tree =&gt; Unit" id="sbt.std.TaskMacro.inputTaskDynMacro0.checkQual">checkQual</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.checkReferences" title="(defs: scala.collection.Set[util.ctx.universe.Symbol], isWrapper: (String, util.ctx.universe.Type, util.ctx.universe.Tree) =&gt; Boolean)util.ctx.universe.Tree =&gt; Unit">checkReferences</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.defs" title="scala.collection.Set[util.ctx.universe.Symbol]">defs</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.isAnyWrapper" title="(String, c.universe.Type, c.universe.Tree) =&gt; Boolean">isAnyWrapper</a><span class="delimiter">)</span>

		<span class="keyword">var</span> <a title="Option[(c.universe.Tree, c.universe.Type, c.universe.ValDef)]" id="sbt.std.TaskMacro.inputTaskDynMacro0.result">result</a>: <span title="Option[(c.universe.Tree, c.universe.Type, c.universe.ValDef)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Type, ValDef<span class="delimiter">)</span><span class="delimiter">]</span> = <span title="None.type">None</span>

		<span class="keyword">def</span> <a title="(tpe: c.universe.Type, qual: c.universe.Tree)c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper">subWrapper</a><span class="delimiter">(</span><a title="c.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tpe">tpe</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.qual">qual</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
			<span title="c.universe.Tree" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.result" title="Option[(c.universe.Tree, c.universe.Type, c.universe.ValDef)]">result</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span>
			<span class="delimiter">{</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Unit">error</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.qual" title="c.universe.Tree">qual</a>.<span title="=&gt; c.universe.Position">pos</span>, <span title="String(&quot;Implementation restriction: a dynamic InputTask can only have a single input parser.&quot;)" class="string">&quot;Implementation restriction: a dynamic InputTask can only have a single input parser.&quot;</span><span class="delimiter">)</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="=&gt; c.universe.Tree">EmptyTree</a>
			<span class="delimiter">}</span>
			<span class="keyword">else</span>
			<span class="delimiter">{</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.qual" title="c.universe.Tree">qual</a>.<span title="(f: c.universe.Tree =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.checkQual" title="util.ctx.universe.Tree =&gt; Unit">checkQual</a><span class="delimiter">)</span>
				<span class="keyword">val</span> <a title="util.ctx.universe.ValDef" id="sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.vd">vd</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.freshValDef" title="(tpe: util.ctx.universe.Type, sym: util.ctx.universe.Symbol)util.ctx.universe.ValDef">freshValDef</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tpe" title="c.universe.Type">tpe</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.qual" title="c.universe.Tree">qual</a>.<span title="=&gt; c.universe.Symbol">symbol</span><span class="delimiter">)</span> <span class="comment">// val $x: &lt;tpe&gt;</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.result" title="Option[(c.universe.Tree, c.universe.Type, c.universe.ValDef)]">result</a> = <span title="(x: (c.universe.Tree, c.universe.Type, util.ctx.universe.ValDef))Some[(c.universe.Tree, c.universe.Type, util.ctx.universe.ValDef)]">Some</span><span class="delimiter">(</span> <span title="(_1: c.universe.Tree, _2: c.universe.Type, _3: util.ctx.universe.ValDef)(c.universe.Tree, c.universe.Type, util.ctx.universe.ValDef)" class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.qual" title="c.universe.Tree">qual</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tpe" title="c.universe.Type">tpe</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.vd" title="util.ctx.universe.ValDef">vd</a><span class="delimiter">)</span> <span class="delimiter">)</span>
				<span class="keyword">val</span> <a title="util.ctx.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tree">tree</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.refVal" title="(vd: util.ctx.universe.ValDef, pos: util.ctx.universe.Position)util.ctx.universe.Tree">refVal</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.vd" title="util.ctx.universe.ValDef">vd</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.qual" title="c.universe.Tree">qual</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span> <span class="comment">// $x</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tree" title="util.ctx.universe.Tree">tree</a>.<span title="(newpos: util.ctx.universe.Position)util.ctx.universe.Tree">setPos</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.qual" title="c.universe.Tree">qual</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span> <span class="comment">// position needs to be set so that wrapKey passes the position onto the wrapper</span>
				<span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tree" title="util.ctx.universe.Tree">tree</a>.<span title="=&gt; util.ctx.universe.Type">tpe</span> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>, <span title="String(&quot;Null type: &quot;)" class="string">&quot;Null type: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tree" title="util.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tree" title="util.ctx.universe.Tree">tree</a>.<span title="(tp: util.ctx.universe.Type)util.ctx.universe.Tree">setType</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper.tree" title="util.ctx.universe.Tree">tree</a>
			<span class="delimiter">}</span>
		<span class="comment">// Tree for InputTask.&lt;name&gt;[&lt;tpeA&gt;, &lt;tpeB&gt;](arg1)(arg2)</span>
		<span class="keyword">def</span> <a title="(name: String, tpeA: c.universe.Type, tpeB: c.universe.Type, arg1: c.universe.Tree, arg2: c.universe.Tree)c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate">inputTaskCreate</a><span class="delimiter">(</span><a title="String" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.name">name</a>: <span title="String">String</span>, <a title="c.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.tpeA">tpeA</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.tpeB">tpeB</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.arg1">arg1</a>: <span title="c.universe.Tree">Tree</span>, <a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.arg2">arg2</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> =
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="c.universe.TypeApply" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.typedApp">typedApp</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.select" title="(t: util.ctx.universe.Tree, name: String)util.ctx.universe.Tree">select</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.it" title="c.universe.Ident">it</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.name" title="String">name</a><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.tpeA" title="c.universe.Type">tpeA</a><span class="delimiter">)</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.typedApp.x$6" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.tpeB" title="c.universe.Type">tpeB</a><span class="delimiter">)</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.typedApp.x$5" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
			<span class="keyword">val</span> <a title="c.universe.Apply" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.app">app</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.typedApp" title="c.universe.TypeApply">typedApp</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.arg1" title="c.universe.Tree">arg1</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.app.x$7" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.arg2" title="c.universe.Tree">arg2</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.app.x$8" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
			<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[sbt.InputTask[T]]])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.InputTask[T]]">Initialize</a><span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate.app" title="c.universe.Apply">app</a><span class="delimiter">)</span>
		<span class="delimiter">}</span>
		<span class="comment">// Tree for InputTask.createFree[&lt;tpe&gt;](arg1)</span>
		<span class="keyword">def</span> <a title="(tpe: c.universe.Type, arg: c.universe.Tree)c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree">inputTaskCreateFree</a><span class="delimiter">(</span><a title="c.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.tpe">tpe</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.arg">arg</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> =
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="c.universe.TypeApply" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.typedApp">typedApp</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.select" title="(t: util.ctx.universe.Tree, name: String)util.ctx.universe.Tree">select</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.it" title="c.universe.Ident">it</a>, <span title="String(&quot;createFree&quot;)">InputTaskCreateFreeName</span><span class="delimiter">)</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.typedApp.x$9" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
			<span class="keyword">val</span> <a title="c.universe.Apply" id="sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.app">app</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.typedApp" title="c.universe.TypeApply">typedApp</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.arg" title="c.universe.Tree">arg</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.app.x$10" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
			<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[sbt.InputTask[T]]])c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.InputTask[T]]">Initialize</a><span class="delimiter">[</span>InputTask<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[sbt.InputTask[T]]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree.app" title="c.universe.Apply">app</a><span class="delimiter">)</span>
		<span class="delimiter">}</span>
		<span class="keyword">def</span> <a title="[I](dyn: Boolean, tx: c.universe.Tree)(implicit evidence$40: c.universe.WeakTypeTag[I])c.Expr[sbt.Def.Initialize[sbt.Task[I]]]" id="sbt.std.TaskMacro.inputTaskDynMacro0.expandTask">expandTask</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.inputTaskDynMacro0.expandTask;I">I</a>: WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Boolean" id="sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.dyn">dyn</a>: <span title="Boolean">Boolean</span>, <a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.tx">tx</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[sbt.Task[I]]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
			<span title="c.Expr[sbt.Def.Initialize[sbt.Task[I]]]" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.dyn" title="Boolean">dyn</a><span class="delimiter">)</span>
				<a href="#sbt.std.TaskMacro.taskDynMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[sbt.Task[T]]])(implicit evidence$2: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">taskDynMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[sbt.Task[I]]])(implicit evidence$2: c.WeakTypeTag[I])c.Expr[sbt.Def.Initialize[sbt.Task[I]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.evidence$40" title="c.universe.WeakTypeTag[I]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[sbt.Task[I]]])c.Expr[sbt.Def.Initialize[sbt.Task[I]]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.Task[I]]">Initialize</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[sbt.Task[I]]]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.tx" title="c.universe.Tree">tx</a><span class="delimiter">)</span> <span class="delimiter">)</span>
			<span class="keyword">else</span>
				<a href="#sbt.std.TaskMacro.taskMacroImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]">taskMacroImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[I])(implicit evidence$1: c.WeakTypeTag[I])c.Expr[sbt.Def.Initialize[sbt.Task[I]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask;I" title="I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.evidence$40" title="c.universe.WeakTypeTag[I]" class="delimiter">(</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[I])c.Expr[I]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask;I" title="I">I</a><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.evidence$40" title="c.universe.WeakTypeTag[I]" class="delimiter">(</a><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask.tx" title="c.universe.Tree">tx</a><span class="delimiter">)</span> <span class="delimiter">)</span>
		<span class="keyword">def</span> <a title="[I](implicit evidence$41: c.universe.WeakTypeTag[I])c.universe.WeakTypeTag[sbt.Def.Initialize[sbt.Task[I]]]" id="sbt.std.TaskMacro.inputTaskDynMacro0.wrapTag">wrapTag</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskMacro.inputTaskDynMacro0.wrapTag;I">I</a>: WeakTypeTag<span class="delimiter">]</span>: <span title="c.universe.WeakTypeTag[sbt.Def.Initialize[sbt.Task[I]]]">WeakTypeTag</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>Task<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(implicit attag: c.universe.WeakTypeTag[sbt.Def.Initialize[sbt.Task[I]]])c.universe.WeakTypeTag[sbt.Def.Initialize[sbt.Task[I]]]">weakTypeTag</a>

		<span class="keyword">def</span> <a title="(name: String, tpe: c.universe.Type, qual: c.universe.Tree)sbt.appmacro.Converted[c.type]" id="sbt.std.TaskMacro.inputTaskDynMacro0.sub">sub</a><span class="delimiter">(</span><a title="String" id="sbt.std.TaskMacro.inputTaskDynMacro0.sub.name">name</a>: <span title="String">String</span>, <a title="c.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.sub.tpe">tpe</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.sub.qual">qual</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="c.WeakTypeTag[T]" id="sbt.std.TaskMacro.inputTaskDynMacro0.sub.tag">tag</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tpe: c.Type)c.WeakTypeTag[T]">WeakTypeTag</span><span title="(tpe: c.Type)c.WeakTypeTag[T]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.sub.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span>
			<a href="InputConvert.scala.html#sbt.std.InitParserConvert.apply" title="(c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$5: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]">InitParserConvert</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.sub.name" title="String">name</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.sub.qual" title="c.universe.Tree">qual</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.sub.tag" title="c.WeakTypeTag[T]">tag</a><span class="delimiter">)</span> <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted.transform" title="(f: c.Tree =&gt; c.Tree)sbt.appmacro.Converted[c.type]">transform</a> <span class="delimiter">{</span> <a title="c.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.sub.$anonfun.tree">tree</a> =&gt;
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.subWrapper" title="(tpe: c.universe.Type, qual: c.universe.Tree)c.universe.Tree">subWrapper</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.sub.tpe" title="c.universe.Type">tpe</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.sub.$anonfun.tree" title="c.Tree">tree</a><span class="delimiter">)</span>
			<span class="delimiter">}</span>
		<span class="delimiter">}</span>

		<span class="keyword">val</span> <a title="util.ctx.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.tx">tx</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.transformWrappers" title="(t: util.ctx.universe.Tree, subWrapper: (String, util.ctx.universe.Type, util.ctx.universe.Tree) =&gt; sbt.appmacro.Converted[util.ctx.type])util.ctx.universe.Tree">transformWrappers</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.ttree" title="c.universe.Tree">ttree</a>, <span class="delimiter">(</span><a title="String" id="sbt.std.TaskMacro.inputTaskDynMacro0.tx.$anonfun.n">n</a>,<a title="util.ctx.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.tx.$anonfun.tpe">tpe</a>,<a title="util.ctx.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.tx.$anonfun.tree">tree</a><span class="delimiter">)</span> =&gt; <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.sub" title="(name: String, tpe: c.universe.Type, qual: c.universe.Tree)sbt.appmacro.Converted[c.type]">sub</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tx.$anonfun.n" title="String">n</a>,<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tx.$anonfun.tpe" title="util.ctx.universe.Type">tpe</a>,<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tx.$anonfun.tree" title="util.ctx.universe.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>
		<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.result" title="Option[(c.universe.Tree, c.universe.Type, c.universe.ValDef)]">result</a> <span title="c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]" class="keyword">match</span> <span class="delimiter">{</span>
			<span class="keyword">case</span> Some<span class="delimiter">(</span><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.p">p</a>, <a title="c.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.tpe">tpe</a>, <a title="c.universe.ValDef" id="sbt.std.TaskMacro.inputTaskDynMacro0.param">param</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
				<span class="keyword">val</span> <a title="c.universe.Function" id="sbt.std.TaskMacro.inputTaskDynMacro0.fCore">fCore</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="(vparams: List[c.universe.ValDef], body: c.universe.Tree)c.universe.Function">Function</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.param" title="c.universe.ValDef">param</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.fCore.x$11" title="(x: c.universe.ValDef)List[c.universe.ValDef]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tx" title="util.ctx.universe.Tree">tx</a><span class="delimiter">)</span>
				<span class="keyword">val</span> <a title="c.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.bodyTpe">bodyTpe</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.wrapTag" title="(implicit evidence$41: c.universe.WeakTypeTag[T])c.universe.WeakTypeTag[sbt.Def.Initialize[sbt.Task[T]]]">wrapTag</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tag" title="c.WeakTypeTag[T]">tag</a><span class="delimiter">)</span>.<span title="=&gt; c.universe.Type">tpe</span>
				<span class="keyword">val</span> <a title="util.ctx.universe.Type" id="sbt.std.TaskMacro.inputTaskDynMacro0.fTpe">fTpe</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="../appmacro/ContextUtil.scala.html#sbt.appmacro;ContextUtil.functionType" title="(args: List[util.ctx.universe.Type], result: util.ctx.universe.Type)util.ctx.universe.Type">functionType</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tpe" title="c.universe.Type">tpe</a> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.fTpe.x$12" title="(x: c.universe.Type)List[c.universe.Type]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.bodyTpe" title="c.universe.Type">bodyTpe</a><span class="delimiter">)</span>
				<span class="keyword">val</span> <a title="c.WeakTypeTag[Any]" id="sbt.std.TaskMacro.inputTaskDynMacro0.fTag">fTag</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tpe: c.Type)c.WeakTypeTag[T]">WeakTypeTag</span><span title="(tpe: c.Type)c.WeakTypeTag[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.fTpe" title="util.ctx.universe.Type">fTpe</a><span class="delimiter">)</span> <span class="comment">// don't know the actual type yet, so use Any</span>
				<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.fInit">fInit</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="(tree: c.Tree)c.Tree">resetLocalAttrs</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask" title="(dyn: Boolean, tx: c.universe.Tree)(implicit evidence$40: c.universe.WeakTypeTag[Any])c.Expr[sbt.Def.Initialize[sbt.Task[Any]]]">expandTask</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.fCore" title="c.universe.Function">fCore</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.fTag" title="c.WeakTypeTag[Any]">fTag</a><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreate" title="(name: String, tpeA: c.universe.Type, tpeB: c.universe.Type, arg1: c.universe.Tree, arg2: c.universe.Tree)c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">inputTaskCreate</a><span class="delimiter">(</span><span title="String(&quot;createDyn&quot;)">InputTaskCreateDynName</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tpe" title="c.universe.Type">tpe</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tag" title="c.WeakTypeTag[T]">tag</a>.<span title="=&gt; c.universe.Type">tpe</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.p" title="c.universe.Tree">p</a>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.fInit" title="c.Tree">fInit</a><span class="delimiter">)</span>
			<span class="keyword">case</span> <span title="None.type">None</span> =&gt;
				<span class="keyword">val</span> <a title="c.Tree" id="sbt.std.TaskMacro.inputTaskDynMacro0.init">init</a> = <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.c" title="scala.reflect.macros.Context">c</a>.<span title="(tree: c.Tree)c.Tree">resetLocalAttrs</span><span class="delimiter">(</span> <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.expandTask" title="[I](dyn: Boolean, tx: c.universe.Tree)(implicit evidence$40: c.universe.WeakTypeTag[I])c.Expr[sbt.Def.Initialize[sbt.Task[I]]]">expandTask</a><span title="(dyn: Boolean, tx: c.universe.Tree)(implicit evidence$40: c.universe.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[sbt.Task[T]]]" class="delimiter">[</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0;T" title="T">T</a><span class="delimiter">]</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.evidence$39" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="Boolean(true)" class="keyword">true</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tx" title="util.ctx.universe.Tree">tx</a><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span> <span class="delimiter">)</span>
				<a href="#sbt.std.TaskMacro.inputTaskDynMacro0.inputTaskCreateFree" title="(tpe: c.universe.Type, arg: c.universe.Tree)c.Expr[sbt.Def.Initialize[sbt.InputTask[T]]]">inputTaskCreateFree</a><span class="delimiter">(</span><a href="#sbt.std.TaskMacro.inputTaskDynMacro0.tag" title="c.WeakTypeTag[T]">tag</a>.<span title="=&gt; c.universe.Type">tpe</span>, <a href="#sbt.std.TaskMacro.inputTaskDynMacro0.init" title="c.Tree">init</a><span class="delimiter">)</span>
		<span class="delimiter">}</span>
	<span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="sbt.std.PlainTaskMacro.type" id="sbt.std.PlainTaskMacro">PlainTaskMacro</a>
<a href="#sbt.std.PlainTaskMacro" title="sbt.std.PlainTaskMacro.type" class="delimiter">{</a>
	<span class="keyword">def</span> <a title="[T](t: T)sbt.Task[T]" id="sbt.std.PlainTaskMacro.task">task</a><span class="delimiter">[</span><a title="" id="sbt.std.PlainTaskMacro.task;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt.std.PlainTaskMacro.task.t">t</a>: <a href="#sbt.std.PlainTaskMacro.task;T" title="T">T</a><span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = macro <a href="#sbt.std.PlainTaskMacro.taskImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$42: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]">taskImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$42: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]" class="delimiter">[</span><a href="#sbt.std.PlainTaskMacro.task;T" title="T">T</a><span class="delimiter">]</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$42: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]" id="sbt.std.PlainTaskMacro.taskImpl">taskImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.PlainTaskMacro.taskImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.PlainTaskMacro.taskImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.PlainTaskMacro.taskImpl.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Task[T]]">Expr</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = 
		<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[sbt.Types.Id[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[sbt.Types.Id[T]]]" class="delimiter">[</span><a href="#sbt.std.PlainTaskMacro.taskImpl;T" title="T">T</a>,<a href="../TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.PlainTaskMacro.taskImpl.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.TaskInstance" title="sbt.std.TaskInstance.type">TaskInstance</a>, <a href="InputConvert.scala.html#sbt.std.TaskConvert" title="sbt.std.TaskConvert.type">TaskConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.PlainTaskMacro.taskImpl.evidence$42" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(a: c.Expr[T])scala.util.Left[c.Expr[T],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.std.PlainTaskMacro.taskImpl.t" title="c.Expr[T]">t</a><span class="delimiter">)</span>, <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.idTransform" title="[C &lt;: scala.reflect.macros.Context with Singleton]=&gt; sbt.appmacro.Instance.Transform[C,sbt.Types.Id]">idTransform</a><span title="sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[T](t: sbt.Task[T])sbt.Task[T]" id="sbt.std.PlainTaskMacro.taskDyn">taskDyn</a><span class="delimiter">[</span><a title="" id="sbt.std.PlainTaskMacro.taskDyn;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[T]" id="sbt.std.PlainTaskMacro.taskDyn.t">t</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = macro <a href="#sbt.std.PlainTaskMacro.taskDynImpl" title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Task[T]])(implicit evidence$43: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]">taskDynImpl</a><span title="(c: scala.reflect.macros.Context)(t: c.Expr[sbt.Task[T]])(implicit evidence$43: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]" class="delimiter">[</span><a href="#sbt.std.PlainTaskMacro.taskDyn;T" title="T">T</a><span class="delimiter">]</span>
	<span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Task[T]])(implicit evidence$43: c.WeakTypeTag[T])c.Expr[sbt.Task[T]]" id="sbt.std.PlainTaskMacro.taskDynImpl">taskDynImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.PlainTaskMacro.taskDynImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.PlainTaskMacro.taskDynImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Task[T]]" id="sbt.std.PlainTaskMacro.taskDynImpl.t">t</a>: c.<span title="c.Expr[sbt.Task[T]]">Expr</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Task[T]]">Expr</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = 
		<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[sbt.Types.Id[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[sbt.Types.Id[T]]]" class="delimiter">[</span><a href="#sbt.std.PlainTaskMacro.taskDynImpl;T" title="T">T</a>,<a href="../TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.PlainTaskMacro.taskDynImpl.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.TaskInstance" title="sbt.std.TaskInstance.type">TaskInstance</a>, <a href="InputConvert.scala.html#sbt.std.TaskConvert" title="sbt.std.TaskConvert.type">TaskConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.PlainTaskMacro.taskDynImpl.evidence$43" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(b: c.Expr[sbt.Task[T]])scala.util.Right[Nothing,c.Expr[sbt.Task[T]]]">Right</span><span class="delimiter">(</span><a href="#sbt.std.PlainTaskMacro.taskDynImpl.t" title="c.Expr[sbt.Task[T]]">t</a><span class="delimiter">)</span>, <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.idTransform" title="[C &lt;: scala.reflect.macros.Context with Singleton]=&gt; sbt.appmacro.Instance.Transform[C,sbt.Types.Id]">idTransform</a><span title="sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
