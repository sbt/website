<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/Sync.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2010  Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

	<span class="keyword">import</span> java.io.File

<span class="comment">/** 
Maintains a set of mappings so that they are uptodate.
Specifically, 'apply' applies the mappings by creating target directories and copying source files to their destination.
For each mapping no longer present, the old target is removed.
Caution: Existing files are overwritten.
Caution: The removal of old targets assumes that nothing else has written to or modified those files.
  It tries not to obliterate large amounts of data by only removing previously tracked files and empty directories.
  That is, it won't remove a directory with unknown (untracked) files in it.
Warning: It is therefore inappropriate to use this with anything other than an automatically managed destination or a dedicated target directory.
Warning: Specifically, don't mix this with a directory containing manually created files, like sources.
It is safe to use for its intended purpose: copying resources to a class output directory.
*/</span>
<span class="keyword">object</span> <a title="sbt.Sync.type" id="sbt.Sync">Sync</a>
<a href="#sbt.Sync" title="sbt.Sync.type" class="delimiter">{</a>
	<span class="keyword">def</span> <a title="(cacheFile: java.io.File, inStyle: sbt.FileInfo.Style, outStyle: sbt.FileInfo.Style)Traversable[(java.io.File, java.io.File)] =&gt; sbt.Relation[java.io.File,java.io.File]" id="sbt.Sync.apply">apply</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.Sync.apply.cacheFile">cacheFile</a>: <span title="java.io.File">File</span>, <a title="sbt.FileInfo.Style" id="sbt.Sync.apply$default$2">inStyle</a>: FileInfo.<a href="FileInfo.scala.html#sbt.FileInfo;Style" title="sbt.FileInfo.Style">Style</a> = <a href="FileInfo.scala.html#sbt.FileInfo" title="sbt.FileInfo.type">FileInfo</a>.<a href="FileInfo.scala.html#sbt.FileInfo.lastModified" title="sbt.FileInfo.lastModified.type">lastModified</a>, <a title="sbt.FileInfo.Style" id="sbt.Sync.apply$default$3">outStyle</a>: FileInfo.<a href="FileInfo.scala.html#sbt.FileInfo;Style" title="sbt.FileInfo.Style">Style</a> = <a href="FileInfo.scala.html#sbt.FileInfo" title="sbt.FileInfo.type">FileInfo</a>.<a href="FileInfo.scala.html#sbt.FileInfo.exists" title="sbt.FileInfo.exists.type">exists</a><span class="delimiter">)</span>: Traversable<span class="delimiter">[</span><span class="delimiter">(</span>File,File<span class="delimiter">)</span><span class="delimiter">]</span> =&gt; Relation<span class="delimiter">[</span>File,File<span class="delimiter">]</span> =
		<a title="Traversable[(java.io.File, java.io.File)]" id="sbt.Sync.apply.$anonfun.mappings">mappings</a> =&gt;
		<span class="delimiter">{</span>
			<span class="keyword">val</span> <a title="sbt.Relation[java.io.File,java.io.File]" id="sbt.Sync.apply.$anonfun.relation">relation</a> = <a href="Relation.scala.html#sbt.Relation" title="sbt.Relation.type">Relation</a>.<a href="Relation.scala.html#sbt.Relation.empty" title="sbt.Relation[java.io.File,java.io.File]">empty</a> <a href="Relation.scala.html#sbt;Relation.++(a4ce55a1b2)" title="(rs: Traversable[(java.io.File, java.io.File)])sbt.Relation[java.io.File,java.io.File]">++</a> <a href="#sbt.Sync.apply.$anonfun.mappings" title="Traversable[(java.io.File, java.io.File)]">mappings</a>
			<a href="#sbt.Sync.noDuplicateTargets" title="(relation: sbt.Relation[java.io.File,java.io.File])Unit">noDuplicateTargets</a><span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a><span class="delimiter">)</span>
			<span class="keyword">val</span> <a title="scala.collection.immutable.Map[java.io.File,inStyle.F]" id="sbt.Sync.apply.$anonfun.currentInfo">currentInfo</a> = <a href="#sbt.Sync.apply.$anonfun.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a>.<a href="Relation.scala.html#sbt;Relation._1s" title="=&gt; scala.collection.Set[java.io.File]">_1s</a>.<span title="(f: java.io.File =&gt; (java.io.File, inStyle.F))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Set[java.io.File],(java.io.File, inStyle.F),scala.collection.Set[(java.io.File, inStyle.F)]])scala.collection.Set[(java.io.File, inStyle.F)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Set.Coll,(java.io.File, inStyle.F),scala.collection.Set[(java.io.File, inStyle.F)]]" class="delimiter">(</span><a title="java.io.File" id="sbt.Sync.apply.$anonfun.currentInfo.$anonfun.s">s</a> =&gt; <span title="(_1: java.io.File, _2: inStyle.F)(java.io.File, inStyle.F)" class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.currentInfo.$anonfun.s" title="java.io.File">s</a>, <a href="FileInfo.scala.html#sbt.FileInfo;Style.apply" title="implicit sbt.FileInfo.Style.apply : (file: java.io.File)inStyle.F">inStyle</a><span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.currentInfo.$anonfun.s" title="java.io.File">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(java.io.File, inStyle.F),(java.io.File, inStyle.F)])scala.collection.immutable.Map[java.io.File,inStyle.F]">toMap</span>

			<span class="keyword">val</span> <a href="#sbt.Sync.apply.$anonfun.previousRelation" title="(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,inStyle.F])" class="delimiter">(</a><a href="#sbt.Sync.apply.$anonfun.x$1" title="sbt.Relation[java.io.File,java.io.File]" id="sbt.Sync.apply.$anonfun.previousRelation">previousRelation</a>, <a href="#sbt.Sync.apply.$anonfun.x$1" title="Map[java.io.File,inStyle.F]" id="sbt.Sync.apply.$anonfun.previousInfo">previousInfo</a><span class="delimiter">)</span> = <a href="#sbt.Sync.readInfo" title="(file: java.io.File)(implicit infoFormat: sbinary.Format[inStyle.F])(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,inStyle.F])">readInfo</a><span class="delimiter">(</span><a href="#sbt.Sync.apply.cacheFile" title="java.io.File">cacheFile</a><span class="delimiter">)</span><span title="(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,inStyle.F]) @unchecked" class="delimiter">(</span><a href="#sbt.Sync.apply$default$2" title="sbt.FileInfo.Style">inStyle</a>.<a href="FileInfo.scala.html#sbt.FileInfo;Style.format" title="=&gt; sbinary.Format[inStyle.F]">format</a><span class="delimiter">)</span>
			<span class="keyword">val</span> <a title="scala.collection.Set[java.io.File]" id="sbt.Sync.apply.$anonfun.removeTargets">removeTargets</a> = <a href="#sbt.Sync.apply.$anonfun.previousRelation" title="sbt.Relation[java.io.File,java.io.File]">previousRelation</a>.<a href="Relation.scala.html#sbt;Relation._2s" title="=&gt; scala.collection.Set[java.io.File]">_2s</a> <span title="(xs: scala.collection.GenTraversableOnce[java.io.File])scala.collection.Set[java.io.File]">--</span> <a href="#sbt.Sync.apply.$anonfun.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a>.<a href="Relation.scala.html#sbt;Relation._2s" title="=&gt; scala.collection.Set[java.io.File]">_2s</a>

			<span class="keyword">def</span> <a title="(source: java.io.File, target: java.io.File)Boolean" id="sbt.Sync.apply.$anonfun.outofdate">outofdate</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.Sync.apply.$anonfun.outofdate.source">source</a>: <span title="java.io.File">File</span>, <a title="java.io.File" id="sbt.Sync.apply.$anonfun.outofdate.target">target</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
				<span title="=&gt; Boolean">!</span><a href="#sbt.Sync.apply.$anonfun.previousRelation" title="sbt.Relation[java.io.File,java.io.File]">previousRelation</a>.<a href="Relation.scala.html#sbt;Relation.contains" title="(a: java.io.File, b: java.io.File)Boolean">contains</a><span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.outofdate.source" title="java.io.File">source</a>, <a href="#sbt.Sync.apply.$anonfun.outofdate.target" title="java.io.File">target</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
				<span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.previousInfo" title="Map[java.io.File,inStyle.F]">previousInfo</a> <span title="(key: java.io.File)Option[inStyle.F]">get</span> <a href="#sbt.Sync.apply.$anonfun.outofdate.source" title="java.io.File">source</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.currentInfo" title="scala.collection.immutable.Map[java.io.File,inStyle.F]">currentInfo</a> <span title="(key: java.io.File)Option[inStyle.F]">get</span> <a href="#sbt.Sync.apply.$anonfun.outofdate.source" title="java.io.File">source</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
				<span title="=&gt; Boolean">!</span><a href="#sbt.Sync.apply.$anonfun.outofdate.target" title="java.io.File">target</a>.<span title="()Boolean">exists</span> <span title="(x: Boolean)Boolean">||</span>
				<a href="#sbt.Sync.apply.$anonfun.outofdate.target" title="java.io.File">target</a>.<span title="()Boolean">isDirectory</span> <span title="(x: Boolean)Boolean">!=</span> <a href="#sbt.Sync.apply.$anonfun.outofdate.source" title="java.io.File">source</a>.<span title="()Boolean">isDirectory</span>

			<span class="keyword">val</span> <a title="sbt.Relation[java.io.File,java.io.File]" id="sbt.Sync.apply.$anonfun.updates">updates</a> = <a href="#sbt.Sync.apply.$anonfun.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a> <a href="Relation.scala.html#sbt;Relation.filter" title="(f: (java.io.File, java.io.File) =&gt; Boolean)sbt.Relation[java.io.File,java.io.File]">filter</a> <a href="#sbt.Sync.apply.$anonfun.outofdate" title="(source: java.io.File, target: java.io.File)Boolean">outofdate</a>

			<span class="keyword">val</span> <a href="#sbt.Sync.apply.$anonfun.cleanDirs" title="(scala.collection.Set[java.io.File], scala.collection.Set[java.io.File])" class="delimiter">(</a><a href="#sbt.Sync.apply.$anonfun.x$3" title="scala.collection.Set[java.io.File]" id="sbt.Sync.apply.$anonfun.cleanDirs">cleanDirs</a>, <a href="#sbt.Sync.apply.$anonfun.x$3" title="scala.collection.Set[java.io.File]" id="sbt.Sync.apply.$anonfun.cleanFiles">cleanFiles</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.updates" title="sbt.Relation[java.io.File,java.io.File]">updates</a>.<a href="Relation.scala.html#sbt;Relation._2s" title="=&gt; scala.collection.Set[java.io.File]">_2s</a> <span title="(elems: scala.collection.GenTraversableOnce[java.io.File])scala.collection.Set[java.io.File]">++</span> <a href="#sbt.Sync.apply.$anonfun.removeTargets" title="scala.collection.Set[java.io.File]">removeTargets</a><span class="delimiter">)</span>.<span title="(p: java.io.File =&gt; Boolean)(scala.collection.Set[java.io.File], scala.collection.Set[java.io.File])">partition</span><span title="(scala.collection.Set[java.io.File], scala.collection.Set[java.io.File]) @unchecked" class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.x$3.$anonfun.x$2" title="java.io.File">_</a>.<span title="()Boolean">isDirectory</span><span class="delimiter">)</span>

			<a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.delete(e58e0d40a2)" title="(files: Iterable[java.io.File])Unit">delete</a><span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.cleanFiles" title="scala.collection.Set[java.io.File]">cleanFiles</a><span class="delimiter">)</span>
			<a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.deleteIfEmpty" title="(dirs: scala.collection.Set[java.io.File])Unit">deleteIfEmpty</a><span class="delimiter">(</span><a href="#sbt.Sync.apply.$anonfun.cleanDirs" title="scala.collection.Set[java.io.File]">cleanDirs</a><span class="delimiter">)</span>
			<a href="#sbt.Sync.apply.$anonfun.updates" title="sbt.Relation[java.io.File,java.io.File]">updates</a>.<a href="Relation.scala.html#sbt;Relation.all" title="=&gt; Traversable[(java.io.File, java.io.File)]">all</a>.<span title="(f: ((java.io.File, java.io.File)) =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#sbt.Sync.copy" title="(source: java.io.File, target: java.io.File)Unit">copy</a> _<span class="delimiter">)</span>.<span title="=&gt; ((java.io.File, java.io.File)) =&gt; Unit">tupled</span><span class="delimiter">)</span>

			<a href="#sbt.Sync.writeInfo" title="(file: java.io.File, relation: sbt.Relation[java.io.File,java.io.File], info: Map[java.io.File,inStyle.F])(implicit infoFormat: sbinary.Format[inStyle.F])Unit">writeInfo</a><span class="delimiter">(</span><a href="#sbt.Sync.apply.cacheFile" title="java.io.File">cacheFile</a>, <a href="#sbt.Sync.apply.$anonfun.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a>, <a href="#sbt.Sync.apply.$anonfun.currentInfo" title="scala.collection.immutable.Map[java.io.File,inStyle.F]">currentInfo</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.Sync.apply$default$2" title="sbt.FileInfo.Style">inStyle</a>.<a href="FileInfo.scala.html#sbt.FileInfo;Style.format" title="=&gt; sbinary.Format[inStyle.F]">format</a><span class="delimiter">)</span>
			<a href="#sbt.Sync.apply.$anonfun.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a>
		<span class="delimiter">}</span>
		
	<span class="keyword">def</span> <a title="(source: java.io.File, target: java.io.File)Unit" id="sbt.Sync.copy">copy</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.Sync.copy.source">source</a>: <span title="java.io.File">File</span>, <a title="java.io.File" id="sbt.Sync.copy.target">target</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
		<span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.Sync.copy.source" title="java.io.File">source</a>.<span title="()Boolean">isFile</span><span class="delimiter">)</span>
			<a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.copyFile" title="(sourceFile: java.io.File, targetFile: java.io.File, preserveLastModified: Boolean)Unit">copyFile</a><span class="delimiter">(</span><a href="#sbt.Sync.copy.source" title="java.io.File">source</a>, <a href="#sbt.Sync.copy.target" title="java.io.File">target</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
		<span class="keyword">else</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Sync.copy.target" title="java.io.File">target</a>.<span title="()Boolean">exists</span><span class="delimiter">)</span> <span class="comment">// we don't want to update the last modified time of an existing directory</span>
		<span class="delimiter">{</span>
			<a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.createDirectory" title="(dir: java.io.File)Unit">createDirectory</a><span class="delimiter">(</span><a href="#sbt.Sync.copy.target" title="java.io.File">target</a><span class="delimiter">)</span>
			<a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.copyLastModified" title="(sourceFile: java.io.File, targetFile: java.io.File)Boolean">copyLastModified</a><span title="Unit" class="delimiter">(</span><a href="#sbt.Sync.copy.source" title="java.io.File">source</a>, <a href="#sbt.Sync.copy.target" title="java.io.File">target</a><span class="delimiter">)</span>
		<span class="delimiter">}</span>

	<span class="keyword">def</span> <a title="(relation: sbt.Relation[java.io.File,java.io.File])Unit" id="sbt.Sync.noDuplicateTargets">noDuplicateTargets</a><span class="delimiter">(</span><a title="sbt.Relation[java.io.File,java.io.File]" id="sbt.Sync.noDuplicateTargets.relation">relation</a>: <a href="Relation.scala.html#sbt;Relation" title="sbt.Relation[java.io.File,java.io.File]">Relation</a><span class="delimiter">[</span>File, File<span class="delimiter">]</span><span class="delimiter">)</span>
	<span class="delimiter">{</span>
		<span class="keyword">val</span> <a title="scala.collection.immutable.Iterable[String]" id="sbt.Sync.noDuplicateTargets.dups">dups</a> = <a href="#sbt.Sync.noDuplicateTargets.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a>.<a href="Relation.scala.html#sbt;Relation.reverseMap" title="=&gt; Map[java.io.File,Set[java.io.File]]">reverseMap</a>.<span title="(p: ((java.io.File, Set[java.io.File])) =&gt; Boolean)scala.collection.immutable.Map[java.io.File,Set[java.io.File]]">filter</span> <a href="#sbt.Sync.noDuplicateTargets.dups.$anonfun.x0$1" title="Boolean" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span title="java.io.File">target</span>, <span title="Set[java.io.File]">srcs</span><span class="delimiter">)</span> =&gt;
			<span title="Set[java.io.File]">srcs</span>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(2)" class="int">2</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="Set[java.io.File]">srcs</span>.<span title="(p: java.io.File =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Sync.noDuplicateTargets.dups.$anonfun.$anonfun.x$4" title="java.io.File">_</a>.<span title="()Boolean">isDirectory</span><span class="delimiter">)</span>
		<span class="delimiter">}</span> <span title="(f: ((java.io.File, Set[java.io.File])) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[java.io.File,Set[java.io.File]],String,scala.collection.immutable.Iterable[String]])scala.collection.immutable.Iterable[String]">map</span> <a href="#sbt.Sync.noDuplicateTargets.dups.$anonfun.x0$2" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span title="java.io.File">target</span>, <span title="Set[java.io.File]">srcs</span><span class="delimiter">)</span> =&gt;
			<span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span> <span title="(x$1: Any)String">+</span> <span title="java.io.File">target</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\nfrom\n\t&quot;)" class="string">&quot;\nfrom\n\t&quot;</span> <span title="(x$1: Any)String">+</span> <span title="Set[java.io.File]">srcs</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n\t\t&quot;)" class="string">&quot;\n\t\t&quot;</span><span class="delimiter">)</span>
		<span class="delimiter">}</span>
		<span title="Unit" class="keyword">if</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Sync.noDuplicateTargets.dups" title="scala.collection.immutable.Iterable[String]">dups</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
			sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Duplicate mappings:&quot;)" class="string">&quot;Duplicate mappings:&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Sync.noDuplicateTargets.dups" title="scala.collection.immutable.Iterable[String]">dups</a>.<span title="=&gt; String">mkString</span><span class="delimiter">)</span>
	<span class="delimiter">}</span>
		
		<span class="keyword">import</span> java.io.<span class="delimiter">{</span>File, IOException<span class="delimiter">}</span>
		<span class="keyword">import</span> sbinary._
		<span class="keyword">import</span> <span title="sbinary.Operations.type">Operations</span>.<span class="delimiter">{</span>read, write<span class="delimiter">}</span>
		<span class="keyword">import</span> <span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>.<span class="delimiter">{</span>FileFormat =&gt; _, _<span class="delimiter">}</span>
		<span class="keyword">import</span> inc.<a href="inc/AnalysisFormats.scala.html#sbt.inc.AnalysisFormats" title="sbt.inc.AnalysisFormats.type">AnalysisFormats</a>._

	<span class="keyword">def</span> <a title="[F &lt;: sbt.FileInfo](file: java.io.File, relation: sbt.Relation[java.io.File,java.io.File], info: Map[java.io.File,F])(implicit infoFormat: sbinary.Format[F])Unit" id="sbt.Sync.writeInfo">writeInfo</a><span class="delimiter">[</span><a title=" &lt;: sbt.FileInfo" id="sbt.Sync.writeInfo;F">F</a> &lt;: FileInfo<span class="delimiter">]</span><span class="delimiter">(</span><a title="java.io.File" id="sbt.Sync.writeInfo.file">file</a>: <span title="java.io.File">File</span>, <a title="sbt.Relation[java.io.File,java.io.File]" id="sbt.Sync.writeInfo.relation">relation</a>: <a href="Relation.scala.html#sbt;Relation" title="sbt.Relation[java.io.File,java.io.File]">Relation</a><span class="delimiter">[</span>File, File<span class="delimiter">]</span>, <a title="Map[java.io.File,F]" id="sbt.Sync.writeInfo.info">info</a>: <span title="Map[java.io.File,F]">Map</span><span class="delimiter">[</span>File, F<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbinary.Format[F]" id="sbt.Sync.writeInfo.infoFormat">infoFormat</a>: <span title="sbinary.Format[F]">Format</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
		<a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.gzipFileOut" title="(file: java.io.File)(f: java.io.OutputStream =&gt; Unit)Unit">gzipFileOut</a><span class="delimiter">(</span><a href="#sbt.Sync.writeInfo.file" title="java.io.File">file</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="java.io.OutputStream" id="sbt.Sync.writeInfo.$anonfun.out">out</a> =&gt;
			<span title="(out: sbinary.Output, value: (sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F]))(implicit writer: sbinary.Writes[(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])])Unit">write</span><a href="inc/AnalysisFormats.scala.html#sbt.inc.AnalysisFormats.relationFormat" title="(implicit bin1: sbinary.Format[sbt.Relation[java.io.File,java.io.File]], implicit bin2: sbinary.Format[Map[java.io.File,F]])sbinary.Format[(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])]" class="delimiter">(</a><a href="#sbt.Sync.writeInfo.$anonfun.out" title="implicit sbinary.Output.javaOutputToOutput : (x: java.io.OutputStream)sbinary.JavaOutput">out</a>, <span title="(_1: sbt.Relation[java.io.File,java.io.File], _2: Map[java.io.File,F])(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])" class="delimiter">(</span><a href="#sbt.Sync.writeInfo.relation" title="sbt.Relation[java.io.File,java.io.File]">relation</a>, <a href="#sbt.Sync.writeInfo.info" title="Map[java.io.File,F]">info</a><span class="delimiter">)</span> <span class="delimiter">)</span>
		<span class="delimiter">}</span>

	<span class="keyword">type</span> <a title="[F](sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])" id="sbt.Sync;RelationInfo">RelationInfo</a><span class="delimiter">[</span><a title="" id="sbt.Sync;RelationInfo;F">F</a><span class="delimiter">]</span> = <span title="(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])" class="delimiter">(</span>Relation<span class="delimiter">[</span>File,File<span class="delimiter">]</span>, Map<span class="delimiter">[</span>File, F<span class="delimiter">]</span><span class="delimiter">)</span>

	<span class="keyword">def</span> <a title="[F &lt;: sbt.FileInfo](file: java.io.File)(implicit infoFormat: sbinary.Format[F])(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])" id="sbt.Sync.readInfo">readInfo</a><span class="delimiter">[</span><a title=" &lt;: sbt.FileInfo" id="sbt.Sync.readInfo;F">F</a> &lt;: FileInfo<span class="delimiter">]</span><span class="delimiter">(</span><a title="java.io.File" id="sbt.Sync.readInfo.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbinary.Format[F]" id="sbt.Sync.readInfo.infoFormat">infoFormat</a>: <span title="sbinary.Format[F]">Format</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])">RelationInfo</span><span class="delimiter">[</span>F<span class="delimiter">]</span> =
		<span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt.Sync.readUncaught" title="(file: java.io.File)(implicit infoFormat: sbinary.Format[F])(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])">readUncaught</a><span class="delimiter">(</span><a href="#sbt.Sync.readInfo.file" title="java.io.File">file</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.Sync.readInfo.infoFormat" title="sbinary.Format[F]">infoFormat</a><span class="delimiter">)</span> <span class="delimiter">}</span>
		<span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="java.io.IOException" id="sbt.Sync.readInfo.e">e</a>: <span title="java.io.IOException">IOException</span> =&gt; <span title="(_1: sbt.Relation[java.io.File,java.io.File], _2: scala.collection.immutable.Map[java.io.File,Nothing])(sbt.Relation[java.io.File,java.io.File], scala.collection.immutable.Map[java.io.File,Nothing])" class="delimiter">(</span><a href="Relation.scala.html#sbt.Relation" title="sbt.Relation.type">Relation</a>.<a href="Relation.scala.html#sbt.Relation.empty" title="sbt.Relation[java.io.File,java.io.File]">empty</a>, <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[java.io.File,Nothing]">empty</span><span class="delimiter">)</span> <span class="delimiter">}</span>

	<span class="keyword">def</span> <a title="[F &lt;: sbt.FileInfo](file: java.io.File)(implicit infoFormat: sbinary.Format[F])(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])" id="sbt.Sync.readUncaught">readUncaught</a><span class="delimiter">[</span><a title=" &lt;: sbt.FileInfo" id="sbt.Sync.readUncaught;F">F</a> &lt;: FileInfo<span class="delimiter">]</span><span class="delimiter">(</span><a title="java.io.File" id="sbt.Sync.readUncaught.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbinary.Format[F]" id="sbt.Sync.readUncaught.infoFormat">infoFormat</a>: <span title="sbinary.Format[F]">Format</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])">RelationInfo</span><span class="delimiter">[</span>F<span class="delimiter">]</span> =
		<a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.gzipFileIn" title="(file: java.io.File)(f: java.io.InputStream =&gt; (sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F]))(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])">gzipFileIn</a><span class="delimiter">(</span><a href="#sbt.Sync.readUncaught.file" title="java.io.File">file</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="java.io.InputStream" id="sbt.Sync.readUncaught.$anonfun.in">in</a> =&gt;
			<span title="[T](in: sbinary.Input)(implicit reader: sbinary.Reads[T])T">read</span><span title="(in: sbinary.Input)(implicit reader: sbinary.Reads[(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])])(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])" class="delimiter">[</span><span title="(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])">RelationInfo</span><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">]</span><a href="inc/AnalysisFormats.scala.html#sbt.inc.AnalysisFormats.relationFormat" title="(implicit bin1: sbinary.Format[sbt.Relation[java.io.File,java.io.File]], implicit bin2: sbinary.Format[Map[java.io.File,F]])sbinary.Format[(sbt.Relation[java.io.File,java.io.File], Map[java.io.File,F])]" class="delimiter">(</a><a href="#sbt.Sync.readUncaught.$anonfun.in" title="implicit sbinary.Input.javaInputToInput : (x: java.io.InputStream)sbinary.JavaInput">in</a><span class="delimiter">)</span>
		<span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
